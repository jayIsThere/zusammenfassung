---
title: KBE
author: Jaehan Kim
date: 2025-04-10
category: KBE
layout: post
---

03.04.2025 - Vorlesung 1: Wiederverwendung von Software 1
-------------

### EinfÃ¼hrung in die Softwarewiederverwendung

- **Definition:** Wiederverwendung bestehender Softwarekomponenten (z. B. Code, Module, Systeme)
- **Motivation:** Geringere Kosten, hÃ¶here QualitÃ¤t, schnellere MarkteinfÃ¼hrung
- **Relevanz:** Besonders wichtig seit 2000 durch wachsende SoftwarekomplexitÃ¤t und Kostendruck


### Skalierung wiederverwendbarer Softwareeinheiten

- **Systeme von Systemen:** Integration ganzer Systeme
- **Anwendungssysteme:** Konfigurierbare Standardsoftware
- **Anwendungsfamilien / Produktlinien:** Gemeinsame Architektur mit AnpassungsmÃ¶glichkeiten
- **Komponenten:** Module mittlerer GranularitÃ¤t
- **Objekte und Funktionen:** Kleinste Einheiten, oft in Bibliotheken


### Vorteile der Wiederverwendung

- **Kosten- und Zeitersparnis:** Weniger Entwicklung und Validierung notwendig
- **ZuverlÃ¤ssigkeit:** Durch getestete und bewÃ¤hrte Komponenten
- **Bessere Ressourcennutzung:** Spezialisten und Standards werden besser genutzt
- **Konsistenz und Standardisierung:** Z. B. bei UI-Komponenten


### Probleme der Wiederverwendung

- **Wartungsprobleme:** Unbekannter Quellcode fÃ¼hrt zu Problemen bei Wartung und Erweiterung
- **Geringe WerkzeugunterstÃ¼tzung:** Besonders fÃ¼r eingebettete Systeme
- **â€Not-invented-hereâ€œ-Syndrom:** Widerstand gegen externe Komponenten
- **Aufwand fÃ¼r Komponentenbibliotheken:** Aufbau und Pflege sind arbeitsintensiv
- **Anpassung erfordert Expertise:** Finden und anpassen von Komponenten ist komplex

---
---
---

10.04.2025 - Vorlesung 2: Wiederverwendung von Software 2
-------------

### Wiederverwendungstechniken (laut Sommerville)

1. **Frameworks**
   - **Definition:** Ein Framework ist ein Set von Softwarekomponenten, das eine Architektur fÃ¼r verwandte Anwendungen bereitstellt.
   - **Beispiel:** Ein Web-Framework wie Spring MVC verwendet das Model-View-Controller-Muster.
   - **Eigenschaft:** Bietet generische FunktionalitÃ¤t und wird erweitert, nicht ersetzt.

2. **Inversion of Control (IoC)**
   - **Prinzip:** Die Steuerung liegt beim Framework, nicht bei der Anwendung. Die Anwendung registriert ihre Komponenten, und das Framework ruft sie bei Bedarf auf.
   - **Beispiel:** Callbacks in Web-Frameworks.

3. **Entwurfsmuster**
   - **Beispiel:** Observer, Strategy sind gÃ¤ngige Muster, um wiederkehrende Probleme zu lÃ¶sen.

4. **Architekturmuster**
   - **Beispiel:** Microservices bieten eine systemweite LÃ¶sung fÃ¼r komplexe Anwendungen.

5. **ERP-Systeme**
   - **Definition:** Unternehmensweite Systeme mit konfigurierbaren Modulen.
   - **Vorteil:** Bietet LÃ¶sungen fÃ¼r die Verwaltung von GeschÃ¤ftsdaten und Prozessen.

6. **Komponentenbasierte Entwicklung**
   - **Prinzip:** Systeme werden aus austauschbaren Komponenten aufgebaut.

7. **Modellgetriebene Entwicklung**
   - **Definition:** Software wird aus plattformunabhÃ¤ngigen Modellen erstellt.

8. **Serviceorientierte Systeme**
   - **Prinzip:** Nutzung verteilter Webservices (z. B. REST, SOAP) zur Kommunikation zwischen Komponenten.

9. **Softwareproduktlinien**
   - **Definition:** Produktfamilien mit einer gemeinsamen Codebasis und variablen Komponenten.


### Framework-Klassifizierung (nach Fayad & Schmidt)

- **Systeminfrastruktur-Frameworks:** Z. B. Kommunikation, GUI, Compiler
- **Middleware-Integrations-Frameworks:** Z. B. Jakarta EE, .NET fÃ¼r Komponentenkommunikation
- **Unternehmensanwendungs-Frameworks:** Z. B. spezialisierte Frameworks fÃ¼r Branchen wie Telekommunikation oder Finanzen.


### Wiederverwendung von Anwendungssystemen

- **Softwareproduktlinien:** Gemeinsamer Kern mit anpassbaren Komponenten
- **Konfigurierbare Systeme:** Ãœber Parameter anpassbar (z. B. ERP-Systeme)
- **Integrierte Systeme:** Kombination verschiedener Anwendungen Ã¼ber Schnittstellen


### Vorteile und Herausforderungen

- **Vorteile:** Schnellere Bereitstellung und geringeres Entwicklungsrisiko
- **Herausforderungen:** Anpassung an Unternehmensprozesse, fehlende Expertise, Auswahl des richtigen Systems

---
---
---


10.04.2025 - Vorlesung 2: Wiederverwendung von Software 2
-------------

### Grundprinzipien des komponentenbasierten Software-Engineerings ### 

**UnabhÃ¤ngige Komponenten**  
- VollstÃ¤ndig konfigurierbar Ã¼ber ihre Schnittstellen  
- Schnittstelle klar getrennt von der Implementierung  
- Austauschbar ohne Ã„nderung am System

**Komponentenstandards**  
- Einheitliche Schnittstellendefinition & Integration  
- Umsetzung Ã¼ber Komponentenmodelle, z.â€¯B.:
    - Schnittstellenbeschreibung
    - Kommunikationsweise zwischen Komponenten

**Middleware**  
- Serverseitige UnterstÃ¼tzung fÃ¼r:
    - Kommunikation verteilter Komponenten
    - Ressourcenmanagement
    - Transaktionsverwaltung, Sicherheit, ParallelitÃ¤t

**Komponentenorientierter Entwicklungsprozess**  
- Anforderungen an vorhandene Komponenten anpassbar  
- Wiederverwendung wÃ¤hrend Planung & Entwicklung


### âš ï¸ Probleme & Herausforderungen im KBSE ### 

**VertrauenswÃ¼rdigkeit der Komponenten**  
- Blackbox-Natur erschwert Vertrauen  
- Kein Quellcode = wenig Transparenz

**Komponentenzertifizierung**  
- Wer zahlt, wer haftet?  
- Keine klare Verantwortung, rechtlich unsicher

**Vorhersage emergenter Eigenschaften**  
- Integration â‰  Summe der Einzelteile  
- Unerwartete Seiteneffekte durch Zusammenspiel

**Anforderungskompromisse**  
- Reale Anforderungen vs. VerfÃ¼gbarkeit  
- Notwendigkeit strukturierter Analysemethoden


### ğŸ§© Zentrale Entwurfsprinzipien im KBSE ### 

**UnabhÃ¤ngigkeit**  
- Komponenten beeinflussen sich nicht gegenseitig

**Klar definierte Schnittstellen**  
- Austauschbar bei stabiler API

**Komponenteninfrastruktur mit Standarddiensten**  
- Weniger Neuentwicklung nÃ¶tig  
- Fokus auf Integration statt Eigenentwicklung


### Komponenten als Dienstanbieter ### 

- Komponenten stellen Dienste bereit und kapseln deren Implementierung.
- Aufgerufen vom System, ohne zu wissen:
    - Wo sie ausgefÃ¼hrt werden
    - In welcher Sprache sie geschrieben sind

**Vorteile**  
- UnabhÃ¤ngig & ausfÃ¼hrbar Ã¼ber ihre Schnittstelle
- Schnittstellenbasiert â†’ kein Zugriff auf internen Zustand nÃ¶tig


###  ğŸ” Komponenten vs. Objekte ### 

| Merkmal                | Komponente                     | Objekt                          |
|------------------------|--------------------------------|---------------------------------|
| **Deployment**          | Direkt auf Plattform installierbar | Teil eines Programms (kompiliert) |
| **Typdefinition**       | Ist eine Instanz               | Basierend auf Klasse (Typ)     |
| **Transparenz**         | Blackbox, Schnittstelle-only   | Oft transparenter               |
| **SprachabhÃ¤ngigkeit**  | SprachunabhÃ¤ngig               | Sprachgebunden (z. B. nur Java) |
| **Standardisierung**    | Muss Komponentenmodell folgen  | Frei definierbar                |


### ğŸ§© Komponentenschnittstellen ### 

**Stellt bereit (provided interface)**  
- API der Komponente â€“ was sie bietet

**BenÃ¶tigt (required interface)**  
- Welche Dienste sie selbst braucht, um korrekt zu funktionieren  
- Definiert nicht, wie diese bereitgestellt werden


### ğŸ¯ Visualisierung in UML (kompakt) ### 

ğŸ§± **Komponente**  
- Wird mit Rechteck + 2 kleinen Rechtecken dargestellt
- EnthÃ¤lt:
    - Realisierungsklassen
    - "Stellt bereit"- und "BenÃ¶tigt"-Schnittstellen (sichtbar an Port-Notationen)


### Schnittstellenspezifikation in Komponentenmodellen ### 

- Komponenten werden Ã¼ber ihre Schnittstellen definiert
- Das Komponentenmodell regelt:
    - Wie Schnittstellen aufgebaut sind
    - In welcher Sprache sie beschrieben werden

**Beispiele**  
- SOAP Webservices â†’ WSDL (XML)
- Jakarta Beans / CDI â†’ Java
- Microsoft .NET â†’ CIL


### ğŸ§© Grundelemente eines Komponentenmodells ### 

| Element              | Beschreibung                                                        |
|----------------------|---------------------------------------------------------------------|
| **Schnittstellen**    | Bereitgestellte + benÃ¶tigte Dienste                                  |
| **Nutzung**           | Globale Bezeichner/Handles (z.â€¯B. URI, JNDI)                         |
| **Bereitstellung & Verpackung** | inkl. Konfigurationsoptionen, Doku, Meta-Infos           |
| **Komposition**       | Wie Komponenten zusammengebaut werden                                |
| **Anpassung**         | Konfigurierbar fÃ¼r konkrete Einsatzszenarien                         |
| **Evolution**         | Austausch- und Update-Regeln                                          |
| **Dokumentation & Namenskonvention** | Strukturierter Zugriff & Ãœbersicht                      |

**Metadatenzugriff**  
- z.â€¯B. via Reflection (Java)


### âš™ï¸ Bereitstellung & Anpassung ### 

- Komponenten sind unabhÃ¤ngig lauffÃ¤hig
- MÃ¼ssen komplett mit benÃ¶tigter Infrastruktur geliefert werden
- Doku & Austauschregeln sind Teil des Modells
- UnterstÃ¼tzung fÃ¼r Konfigurierbarkeit & Wiederverwendbarkeit


### ğŸ› ï¸ Middleware-Dienste im Komponentenmodell ### 

**Zwei Kategorien:**  
1. **Plattformdienste**  
    (grundlegend fÃ¼r verteilte Kommunikation)
    - Komponentenkommunikation
    - Ressourcenverwaltung
    - Adressierung
    - Ausnahmebehandlung
    - Transaktionsverwaltung
    - Informationssicherheit
    - Persistenz
    - NebenlÃ¤ufigkeit

2. **Hilfsdienste**  
    (ergÃ¤nzend, z.â€¯B. Authentifizierung)
    - Entlasten die Entwicklung, verhindern InkompatibilitÃ¤ten


### ğŸ§ƒ Container als Laufzeitumgebung ### 

- **Container** = Laufzeitumgebung mit Middleware-Diensten
- Besteht aus:
    - Dienstimplementierungen
    - Definitionen fÃ¼r Schnittstellenintegration

**Effekt:**  
- Komponente nutzt Containerdienste Ã¼ber bereitgestellte Schnittstelle  
- Kommunikation mit anderen Komponenten lÃ¤uft indirekt Ã¼ber Proxys

**Beispiel:**  
- EJB-Container (mÃ¤chtig, komplex)
- Spring Framework (leichtgewichtig, effizienter)

---
---
---


Ãœbungsblatt 1
-------------

### Aufgabe 1. Grundstrategie des Software-Engineerings

**Ziel der Wiederverwendung**:  
- Wiederverwendung vorhandener Software, statt neue Software von Grund auf zu entwickeln.


### Aufgabe 2. Aspekte, die den Ansatz getrieben haben:

- Geringere Produktions- und Wartungskosten
- Schnellere Auslieferung von Systemen
- HÃ¶here SoftwarequalitÃ¤t


### Aufgabe 3. Beispiele fÃ¼r etablierte wiederverwendbare Software:

- Open Source Code (z.â€¯B. Apache Commons)
- ERP-Systeme (z.â€¯B. SAP)
- Komponentenbibliotheken
- Webservices (z.â€¯B. PayPal)


### Aufgabe 4. GrÃ¶ÃŸenordnungen von Softwareeinheiten (von groÃŸ nach klein):

- Systeme
- Anwendungen
- Softwareproduktlinien
- Komponenten
- Objekte und Funktionen


### Aufgabe 5. Beispiele fÃ¼r jede GrÃ¶ÃŸenordnung:

- **System**: Ein ERP-System, z.â€¯B. SAP
- **Anwendung**: Ein CRM-System
- **Produktlinie**: Softwarelinie fÃ¼r medizinische GerÃ¤te
- **Komponente**: Zahlungsmodul
- **Funktion/Objekt**: Logging-Klasse aus Apache Commons


### Aufgabe 6. Vorteile der Wiederverwendung:

- Geringere Kosten
- HÃ¶here ZuverlÃ¤ssigkeit
- Geringeres Entwicklungsrisiko
- Schnellere MarkteinfÃ¼hrung
- Effektiver Einsatz von Experten
- StandardkonformitÃ¤t


### Aufgabe 6. Probleme der Wiederverwendung:

- HÃ¶here Wartungskosten
- Mangel an WerkzeugunterstÃ¼tzung
- "Not-invented-here"-Syndrom
- Hoher Aufwand fÃ¼r Bibliotheksverwaltung
- Schwierige Suche und Anpassung von Komponenten


### Aufgabe 7. Planung der Wiederverwendung

**Vier SchlÃ¼sselfaktoren:**

- Entwicklungszeitplan
- Erwartete Lebensdauer der Software
- Erfahrung des Entwicklerteams
- Wichtigkeit/Nicht-funktionale Anforderungen


### Aufgabe 8. SchlÃ¼sselfaktoren bei .NET und schneller VerfÃ¼gbarkeit:

- PlattformabhÃ¤ngigkeit (â†’ .NET-KompatibilitÃ¤t)
- Geringer Entwicklungsaufwand durch Wiederverwendung fertiger Systeme


### Aufgabe 9-12. Anwendungsframeworks

**Attribute von Frameworks:**

| Attribut | Passt? |
|----------|--------|
| Konfigurierbar | âœ… Ja |
| Generisch | âœ… Ja |
| Call-back | âœ… Ja |
| UnterstÃ¼tzung konkreter GeschÃ¤ftsaktivitÃ¤ten | âœ… Ja |
| Inversion of Control | âœ… Ja |
| InhÃ¤rent erweiterbar | âœ… Ja |
| Basis sehr Ã¤hnlicher Systeme | âœ… Ja |
| UnterstÃ¼tzung fÃ¼r Hardware-Schnittstellen | âŒ Teilweise (meist Software) |
| Immer objektorientiert | âŒ Nein (meist, aber nicht zwingend) |

**Drei Architektur- und Entwurfsmuster, auf denen WAFs basieren:**

- Model-View-Controller (MVC)
- Observer Pattern
- Strategy Pattern (auch Composite Pattern mÃ¶glich)

**Funktion von WAFs oder Entwicklern:**

| Funktion | WAF | ENT |
|----------|-----|-----|
| Zahlungstransaktion Ã¼ber Kreditkarte durchfÃ¼hren |  | âœ… |
| Verwaltung des Inhalts eines Shop-Warenkorbs | âœ… |  |
| Abfragedaten in einer Tabelle aufbereiten | âœ… |  |
| Am System anmelden und abmelden | âœ… |  |
| Zugriff auf ein Geoinformationsdienst |  | âœ… |
| Bestimmung des aktuellen Standorts Ã¼ber GPS |  | âœ… |
| Asynchrone Aktualisierung durch Auswahl eines Listeneintrags | âœ… |  |
| GeÃ¤nderte Daten nach dem Speichern sichtbar machen | âœ… |  |
| Ermittlung verschiedener Bahn-Routen |  | âœ… |
| Nutzung einer 3D-Spiele-Engine |  | âœ… |
| GeschÃ¤ftsdaten persistieren | âœ… |  |

**Unterschied Framework vs. Bibliothek:**

- Bei **Bibliotheken** ruft die Anwendung die Bibliothek auf.
- Bei **Frameworks** ruft das Framework die Anwendung auf.
    - â†’ Inversion of Control (IoC, â€Hollywood Principleâ€œ: "Don't call us, we'll call you")


### Aufgabe 13-15. Softwareproduktlinien

**Was ist eine Softwareproduktlinie und wann ist sie effizient?**  
- Eine Produktlinie ist ein Satz verwandter Anwendungen mit gemeinsamer Architektur.
- Effizient, wenn viele Ã¤hnliche, aber nicht identische Systeme benÃ¶tigt werden.

**Aufbau des Basissystems:**

- Kernkomponenten (nicht verÃ¤nderbar)
- Konfigurierbare Komponenten
- Spezielle Anwendungskomponenten

**Voraussetzung bei Nutzung von Frameworks fÃ¼r Produktlinien:**

- Das Framework muss erweiterbar und anpassbar sein, um domÃ¤nenspezifische Komponenten einzubetten.

### Aufgabe 16-19. Anwendungssysteme

**Welche Aussagen Ã¼ber Anwendungssysteme sind korrekt?**

| Aussage | Ja |
|---------|-----|
| Lassen sich viel schneller zuverlÃ¤ssig bereitstellen | âœ… |
| Sind im Kern sehr gut auf kundenspezifische BedÃ¼rfnisse zugeschnitten | âŒ |
| Support-RatschlÃ¤ge = Verkaufsfokus, nicht Bedarfsermittlung | âœ… |
| Gut zur Abbildung bestehender GeschÃ¤ftsprozesse geeignet | âœ… |
| Anpassbar ohne Quellcode-Ã„nderung | âœ… |
| Technologie-Updates = Verantwortung des Herstellers | âœ… |
| FÃ¼r Unternehmen mit Ã¤hnlichen Systemanforderungen geeignet | âœ… |

**Zwei AnsÃ¤tze von Anwendungssystemen:**

- **Konfigurierbare Anwendungssysteme**: Einzelprodukt, Konfiguration
- **Integration von Anwendungssystemen**: Mehrere Systeme, Anpassung durch Integration

**Zuordnung der Aussagen:**

| Aussage | Ansatz |
|---------|--------|
| Schwerpunkt: Systemintegration | 2 |
| Systemanbieter liefert Plattform | 1 |
| Einzelprodukt liefert benÃ¶tigte FunktionalitÃ¤t | 1 |
| Entwicklung flexibler LÃ¶sungen fÃ¼r Kundenprozesse | 2 |
| System basiert auf generischer LÃ¶sung und standardisierten Prozessen | 1 |
| Wartung = Verantwortung des Systembesitzers | 2 |

**Beispielsysteme fÃ¼r beide AnsÃ¤tze:**

- **Konfigurierbares Anwendungssystem**: SAP ERP
- **Integriertes Anwendungssystem**: E-Commerce-System mit ERP- und E-Mail-Anbindung

---
---
---

Ãœbungsblatt 2
-------------

### Aufgabe 1. BeweggrÃ¼nde fÃ¼r die Entstehung des Komponentenbasierten Software-Engineerings

**Wiederverwendbarkeit**:  
- Softwarekomponenten kÃ¶nnen wiederverwendet werden, was Entwicklungszeit und Kosten spart.

**ModularitÃ¤t**:  
- Komponenten sind unabhÃ¤ngig, was Wartung und Erweiterung vereinfacht.

**FlexibilitÃ¤t**:  
- Komponenten kÃ¶nnen ausgetauscht werden, ohne das gesamte System zu Ã¤ndern.

**Skalierbarkeit**:  
- Komponenten kÃ¶nnen unabhÃ¤ngig skaliert und optimiert werden.


### Aufgabe 2. Vier Grundlagen des Komponentenbasierten Software-Engineerings

**UnabhÃ¤ngige Komponenten**:  
- Komponenten kÃ¶nnen ohne SystemÃ¤nderungen ausgetauscht werden.

**Komponentenstandards**:  
- Einheitliche Schnittstellen und Integrationen sind wichtig.

**Middleware**:  
- UnterstÃ¼tzung fÃ¼r Kommunikation, Ressourcenmanagement, Transaktionen, Sicherheit und ParallelitÃ¤t.

**Komponentenorientierter Entwicklungsprozess**:  
- Komponenten kÃ¶nnen wÃ¤hrend der Planung und Entwicklung angepasst und wiederverwendet werden.


### Aufgabe 3. Probleme der VertrauenswÃ¼rdigkeit von Komponenten

**Blackbox-Natur**:  
- Quellcode nicht verfÃ¼gbar, schwierige Transparenz.

**Kein Zugriff auf den Quellcode**:  
- Es ist schwierig, Fehler zu erkennen.

**Unerwartete Seiteneffekte**:  
- Das Zusammenspiel von Komponenten kann unvorhergesehene Probleme verursachen.


### Aufgabe 4. Drei grundlegende Entwurfsprinzipien des Komponentenbasierten Software-Engineerings

**UnabhÃ¤ngigkeit**:  
- Komponenten beeinflussen sich nicht gegenseitig.

**Klar definierte Schnittstellen**:  
- Stabiler API-Austausch mÃ¶glich.

**Komponenteninfrastruktur mit Standarddiensten**:  
- Weniger Eigenentwicklung notwendig, Fokus auf Integration.


### Aufgabe 5. Eigenschaften von Komponenten (Sommerville)

**UnabhÃ¤ngigkeit**:  
- Komponenten sind autonome Einheiten.

**ModularitÃ¤t**:  
- Komponenten sind isolierte Einheiten, die unabhÃ¤ngig entwickelt werden kÃ¶nnen.

**Wiederverwendbarkeit**:  
- Komponenten kÃ¶nnen in verschiedenen Systemen verwendet werden.

**Dienstanbieter**:  
- Komponenten bieten Dienste, ohne dass der Benutzer den internen Zustand kennt.


### Aufgabe 6. Kritische Vorteile der Betrachtung einer Komponente als Dienstanbieter

**UnabhÃ¤ngigkeit**:  
- Komponenten werden Ã¼ber Schnittstellen aufgerufen und sind nicht von der Umgebung abhÃ¤ngig.

**SprachunabhÃ¤ngigkeit**:  
- Komponenten kÃ¶nnen in verschiedenen Programmiersprachen implementiert werden.


### Aufgabe 7. Unterschiede zwischen Komponenten und Objekten

| Merkmal              | Komponente                        | Objekt                         |
|----------------------|-----------------------------------|--------------------------------|
| **Deployment**        | Direkt auf Plattform installierbar | Teil eines Programms (kompiliert) |
| **Typdefinition**     | Instanz                           | Basierend auf Klasse (Typ)    |
| **Transparenz**       | Blackbox (nur Schnittstelle sichtbar) | Oft transparenter (mehr Einblick) |
| **SprachabhÃ¤ngigkeit**| SprachunabhÃ¤ngig                  | Sprachgebunden (z. B. Java)    |
| **Standardisierung**  | Muss Modell folgen                | Frei definierbar               |


### Aufgabe 8. Unterschiedliche Schnittstellen von Komponenten

**Bereitgestellte Schnittstelle (provided interface)**:  
- Definiert die Dienste, die von der Komponente angeboten werden.

**BenÃ¶tigte Schnittstelle (required interface)**:  
- Definiert, welche Dienste die Komponente benÃ¶tigt, ohne zu spezifizieren, wie sie bereitgestellt werden.


### Aufgabe 8. UML-Diagramm

---


### Aufgabe 10. UML-Darstellung der â€DataBrokerâ€œ-Komponente

- Eine Komponente wird durch ein Rechteck dargestellt, das die Schnittstellen und die dazugehÃ¶rigen â€bereitgestelltenâ€œ und â€benÃ¶tigtenâ€œ Schnittstellen (mit kleinen Rechtecken) enthÃ¤lt.


### Aufgabe 11. Prinzip eines Komponentenmodells

**Prinzip**:  
- Ein Komponentenmodell definiert, wie Komponenten strukturiert, interagieren und konfiguriert werden.

**Beispiele**:  
- SOAP (WSDL), Jakarta Beans (CDI), Microsoft .NET (CIL).


### Aufgabe 12. Drei allgemeine Aspekte der Grundelemente eines Komponentenmodells

**Schnittstellen**:  
- Definiert die bereitgestellten und benÃ¶tigten Dienste.

**Nutzung**:  
- Globale Bezeichner (z. B. URI, JNDI).

**Bereitstellung & Verpackung**:  
- Konfiguration, Dokumentation und Meta-Informationen.


### Aufgabe 13. Unterschied zwischen Plattform- und Hilfsdiensten einer Middleware

**Plattformdienste**:  
- Grundlegende Funktionen wie Kommunikation, Ressourcenverwaltung, Transaktionen, Persistenz.

**Hilfsdienste**:  
- ErgÃ¤nzende Dienste wie Authentifizierung, die InkompatibilitÃ¤ten verhindern.


### Aufgabe 14. Implementierung eines Komponentenmodells

**Container**:  
- Eine Laufzeitumgebung, die Middleware-Dienste fÃ¼r die AusfÃ¼hrung von Komponenten bereitstellt.


### Aufgabe 15. Aussagen zu Containern und Komponenten

| Aussage                                                         | Ja/Nein |
|-----------------------------------------------------------------|---------|
| Ein Container ist die Hauptkomponente jeder Applikation         | Nein    |
| Eine Komponente kann auf den Transaktionsdienst zugreifen      | Ja      |
| Der Container ermÃ¶glicht, dass Komponente A auf die Schnittstelle von B zugreifen kann | Ja      |
| Komponenten sind Hilfsdienste des Containers                    | Nein    |
| Der Container kann auf Komponentenschnittstellen zugreifen      | Nein    |
| Die Adressierung von Komponenten ist ein Hilfsdienst des Containers | Ja      |

---
---
---
#### Ãœbungsblatt 3
-------------

#### Ãœbungsblatt 4
-------------



Mamechishiki
-------------

1. ìœ ì—°ì„± (Flexibility)
ì˜ˆì‹œ: ì„œë¹„ìŠ¤ êµ¬í˜„ì²´ ë³€ê²½

    ìƒí™©: UserControllerê°€ UserServiceë¥¼ í˜¸ì¶œí•˜ê³  ìˆëŠ”ë°, ê·¸ë™ì•ˆ **UserService**ëŠ” ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì‚¬ìš©ì ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ëŠ” ë°©ì‹ìœ¼ë¡œ êµ¬í˜„ë˜ì—ˆìŠµë‹ˆë‹¤. ê·¸ëŸ°ë° ìƒˆë¡œìš´ ìš”êµ¬ ì‚¬í•­ì´ ìƒê²¼ì–´ìš”. ì´ì œëŠ” ì™¸ë¶€ APIì—ì„œ ì‚¬ìš©ì ì •ë³´ë¥¼ ê°€ì ¸ì™€ì•¼ í•œë‹¤ê³  í•©ë‹ˆë‹¤.

ì§ì ‘ ê°ì²´ ìƒì„± ë°©ì‹ (ìˆ˜ì •ì´ í•„ìš”í•¨)

public class UserController {
    private UserService userService = new UserService(); // ì§ì ‘ ê°ì²´ ìƒì„±

    public void getUserInfo() {
        userService.fetchUserData();
    }
}

    ë§Œì•½ **UserService**ì˜ êµ¬í˜„ì´ ë³€ê²½ëœë‹¤ë©´, UserControllerë„ ìˆ˜ì •í•´ì•¼ í•©ë‹ˆë‹¤. API í˜¸ì¶œì„ í†µí•œ ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°ë¡œ ë³€ê²½í•˜ë ¤ë©´, UserControllerì˜ ì½”ë“œì—ì„œ **UserService**ë¥¼ ìƒˆë¡œ ì‘ì„±ëœ API í˜¸ì¶œ ì„œë¹„ìŠ¤ë¡œ êµì²´í•´ì•¼ê² ì£ .

ì˜ì¡´ì„± ì£¼ì… (ìœ ì—°í•¨)

@RestController
public class UserController {
    private final UserService userService;

    @Autowired
    public UserController(UserService userService) {
        this.userService = userService; // Springì´ ìë™ìœ¼ë¡œ ì£¼ì…
    }

    public void getUserInfo() {
        userService.fetchUserData();
    }
}

    UserControllerëŠ” ì´ì œ UserServiceì— ì˜ì¡´í•˜ì§€ë§Œ êµ¬í˜„ì²´ì— ëŒ€í•œ êµ¬ì²´ì ì¸ ì‚¬í•­ì€ ì‹ ê²½ ì“°ì§€ ì•ŠìŠµë‹ˆë‹¤.

    ë§Œì•½ **UserService**ë¥¼ **UserApiService**ë¡œ êµì²´í•˜ê³  ì‹¶ë‹¤ë©´, Spring ì„¤ì •ë§Œ ìˆ˜ì •í•˜ë©´ ë©ë‹ˆë‹¤. UserController ì½”ë“œëŠ” ë³€ê²½í•˜ì§€ ì•Šì•„ë„ ë¼ìš”.

    ì˜ˆë¥¼ ë“¤ì–´, Spring ì»¨í…Œì´ë„ˆì— UserService ëŒ€ì‹  UserApiServiceë¥¼ ë“±ë¡í•˜ë©´, Springì´ ìë™ìœ¼ë¡œ UserApiServiceë¥¼ ì£¼ì…í•´ì¤ë‹ˆë‹¤. ê·¸ë§Œí¼ ìœ ì—°ì„±ì´ ë†’ì•„ì§‘ë‹ˆë‹¤.

2. í…ŒìŠ¤íŠ¸ ìš©ì´ì„± (Testability)
ì˜ˆì‹œ: Mock ê°ì²´ë¥¼ ì´ìš©í•œ í…ŒìŠ¤íŠ¸

    ìƒí™©: UserServiceë¥¼ í…ŒìŠ¤íŠ¸í•˜ëŠ”ë°, ì‹¤ì œ ë°ì´í„°ë² ì´ìŠ¤ë‚˜ ì™¸ë¶€ APIë¥¼ í˜¸ì¶œí•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, ì„œë¹„ìŠ¤ ë¡œì§ë§Œ í…ŒìŠ¤íŠ¸í•˜ê³  ì‹¶ì–´ìš”. ì´ë ‡ê²Œ ë˜ë©´ ë°ì´í„°ë² ì´ìŠ¤ë‚˜ API í˜¸ì¶œì„ Mock ì²˜ë¦¬í•´ì„œ í…ŒìŠ¤íŠ¸í•  ìˆ˜ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.

ì§ì ‘ ê°ì²´ ìƒì„± ë°©ì‹ (í…ŒìŠ¤íŠ¸ ì–´ë ¤ì›€)

public class UserController {
    private UserService userService = new UserService(); // ì‹¤ì œ ê°ì²´ë¥¼ ì§ì ‘ ìƒì„±

    public void getUserInfo() {
        userService.fetchUserData(); // ì‹¤ì œ ë°ì´í„°ë² ì´ìŠ¤ í˜¸ì¶œ
    }
}

    UserControllerì—ì„œ **UserService**ë¥¼ ì§ì ‘ ìƒì„±í•˜ë©´, í…ŒìŠ¤íŠ¸í•  ë•Œë§ˆë‹¤ ì‹¤ì œ ë°ì´í„°ë² ì´ìŠ¤ë‚˜ API í˜¸ì¶œì„ í•´ì•¼ í•˜ë¯€ë¡œ, í…ŒìŠ¤íŠ¸ê°€ ë³µì¡í•˜ê³  ëŠë ¤ì§‘ë‹ˆë‹¤.

    ë°ì´í„°ë² ì´ìŠ¤ì™€ ì™¸ë¶€ APIëŠ” í…ŒìŠ¤íŠ¸ í™˜ê²½ì—ì„œ ì„¤ì •í•˜ê¸° ì–´ë ¤ìš´ ê²½ìš°ë„ ë§ê¸° ë•Œë¬¸ì—, í…ŒìŠ¤íŠ¸í•˜ê¸° í˜ë“  ìƒí™©ì´ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì˜ì¡´ì„± ì£¼ì… (í…ŒìŠ¤íŠ¸ ìš©ì´ì„±)

public class UserControllerTest {
    @Mock
    private UserService userService; // Mock ê°ì²´ ì‚¬ìš©

    private UserController userController;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        userController = new UserController(userService); // Mock ê°ì²´ ì£¼ì…
    }

    @Test
    public void testGetUserInfo() {
        when(userService.fetchUserData()).thenReturn("Test User Data");

        String result = userController.getUserInfo();

        assertEquals("Test User Data", result);
    }
}

    UserControllerëŠ” ì´ì œ **UserService**ë¥¼ ì˜ì¡´ì„± ì£¼ì…ë°›ê¸° ë•Œë¬¸ì—, ì‹¤ì œ ë°ì´í„°ë² ì´ìŠ¤ë‚˜ API í˜¸ì¶œì„ í•˜ì§€ ì•Šê³ ë„ Mock ê°ì²´ë¥¼ ì£¼ì…í•˜ì—¬ í…ŒìŠ¤íŠ¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

    Mockitoì™€ ê°™ì€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ì—¬ UserServiceë¥¼ Mock ì²˜ë¦¬í•˜ê³ , ì›í•˜ëŠ” ë°ì´í„°ë¥¼ ë°˜í™˜í•˜ê²Œ ì„¤ì •í•  ìˆ˜ ìˆì–´ìš”.

    ì´ ë°©ì‹ìœ¼ë¡œ ì‹¤ì œ ì„œë¹„ìŠ¤ê°€ ì•„ë‹Œ **ê°€ì§œ ì„œë¹„ìŠ¤(Mock)**ë¥¼ ì‚¬ìš©í•´ í…ŒìŠ¤íŠ¸í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì—, í…ŒìŠ¤íŠ¸ê°€ ë¹ ë¥´ê³  íš¨ìœ¨ì ì…ë‹ˆë‹¤.
    
    
    
    
    
    ...
    
    
    ì˜ˆì‹œ: UserServiceë¥¼ UserApiServiceë¡œ êµì²´í•˜ê¸°
1. UserService ì¸í„°í˜ì´ìŠ¤ì™€ êµ¬í˜„ì²´ (UserServiceImpl)

public interface UserService {
    void fetchUserData();
}

@Service
public class UserServiceImpl implements UserService {
    @Override
    public void fetchUserData() {
        // DBì—ì„œ ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    }
}

2. UserApiService êµ¬í˜„ì²´

@Service
public class UserApiService implements UserService {
    @Override
    public void fetchUserData() {
        // ì™¸ë¶€ APIì—ì„œ ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    }
}

3. Spring ì„¤ì •ë§Œ ìˆ˜ì • (êµ¬í˜„ì²´ ë³€ê²½)

@Configuration
public class ServiceConfig {

    @Bean
    public UserService userService() {
        // ì—¬ê¸°ì„œ ê¸°ì¡´ UserServiceImplì„ UserApiServiceë¡œ ë°”ê¿”ì£¼ë©´ ë¨
        return new UserApiService();
    }
}



....


SOLID

1. âœ… ë‹¨ì¼ ì±…ì„ ì›ì¹™ (Single Responsibility Principle)

    í´ë˜ìŠ¤ëŠ” í•˜ë‚˜ì˜ ì¼ë§Œ í•´ì•¼ í•œë‹¤.

ì˜ˆ:
UserServiceëŠ” "íšŒì› ê°€ì…"ë§Œ í•´ì•¼ì§€, "íŒŒì¼ ì €ì¥"ê¹Œì§€ í•´ë²„ë¦¬ë©´ ë„ˆë¬´ ë°”ë¹ ì ¸.
â†’ ê¸°ëŠ¥ì„ ë‚˜ëˆ„ë©´ ìœ ì§€ë³´ìˆ˜ê°€ ì‰¬ì›Œì ¸!
2. ğŸšª ê°œë°©-íì‡„ ì›ì¹™ (Open/Closed Principle)

    ì½”ë“œëŠ” í™•ì¥ì—ëŠ” ì—´ë ¤ ìˆê³ , ë³€ê²½ì—ëŠ” ë‹«í˜€ ìˆì–´ì•¼ í•œë‹¤.

ì˜ˆ:
ìƒˆë¡œìš´ ê²°ì œ ë°©ì‹ ì¶”ê°€í•  ë•Œ ê¸°ì¡´ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ì§€ ë§ê³ , ìƒˆ í´ë˜ìŠ¤ë¥¼ ì¶”ê°€í•˜ì!
â†’ ê¸°ì¡´ ì½”ë“œ ì•ˆ ê±´ë“œë¦¬ê³ ë„ ê¸°ëŠ¥ì„ í™•ì¥í•  ìˆ˜ ìˆìŒ!
3. ğŸ§¬ ë¦¬ìŠ¤ì½”í”„ ì¹˜í™˜ ì›ì¹™ (Liskov Substitution Principle)

    ìì‹ í´ë˜ìŠ¤ëŠ” ë¶€ëª¨ í´ë˜ìŠ¤ë¥¼ ì™„ì „íˆ ëŒ€ì²´í•  ìˆ˜ ìˆì–´ì•¼ í•¨.

ì˜ˆ:
Bird â†’ Penguin ìƒì†í–ˆëŠ”ë°, fly() í˜¸ì¶œí•˜ë‹ˆ ì˜¤ë¥˜ë‚¨?
â†’ ê·¸ëŸ¼ LSP ìœ„ë°˜! ë¶€ëª¨ ëŒ€ì²´ê°€ ì•ˆ ë˜ì–ì•„ ğŸ˜…
4. ğŸ§© ì¸í„°í˜ì´ìŠ¤ ë¶„ë¦¬ ì›ì¹™ (Interface Segregation Principle)

    ì¸í„°í˜ì´ìŠ¤ëŠ” ì‘ê³  êµ¬ì²´ì ìœ¼ë¡œ ë‚˜ëˆ ë¼.

ì˜ˆ:
Animal ì¸í„°í˜ì´ìŠ¤ì— walk(), fly(), swim()ì´ ë‹¤ ìˆìœ¼ë©´...
ê³ ì–‘ì´ë„ fly() êµ¬í˜„í•´ì•¼ í•œë‹¤ê³ ?! ğŸ¤¯
â†’ ê¸°ëŠ¥ë³„ ì¸í„°í˜ì´ìŠ¤ë¡œ ë¶„ë¦¬í•˜ì!
5. ğŸ”„ ì˜ì¡´ì„± ì—­ì „ ì›ì¹™ (Dependency Inversion Principle)

    êµ¬í˜„ì²´ê°€ ì•„ë‹ˆë¼ ì¸í„°í˜ì´ìŠ¤(ì¶”ìƒ)ì— ì˜ì¡´í•´ë¼
    â†’ ì´ë¯¸ ì•ì—ì„œ ì„¤ëª…í–ˆì§€? ğŸ˜Š
    
    
    
    ...
    
    
    ğŸ”„ ì»´í¬ë„ŒíŠ¸ ê¸°ë°˜ ì†Œí”„íŠ¸ì›¨ì–´ ê³µí•™ vs Spring Boot
âœ… 1. ì»´í¬ë„ŒíŠ¸ = ìŠ¤í”„ë§ ë¹ˆ (@Component, @Service ë“±)

    KBSEì—ì„œëŠ” 'ì»´í¬ë„ŒíŠ¸'ë¥¼ ë…ë¦½ì ìœ¼ë¡œ ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì†Œí”„íŠ¸ì›¨ì–´ ë‹¨ìœ„ë¡œ ì„¤ëª…í–ˆì§€?

    ìŠ¤í”„ë§ì—ì„œëŠ” ì´ëŸ° ë‹¨ìœ„ë¥¼ @Component, @Service, @Repository, @Controller ê°™ì€ ì• ë…¸í…Œì´ì…˜ìœ¼ë¡œ ë“±ë¡í•œ **ë¹ˆ(Bean)**ì´ë¼ê³  ë³´ë©´ ë¼.

ğŸ‘‰ ì˜ˆì‹œ:

@Service
public class UserService {
    public String getUser() {
        return "í™ê¸¸ë™";
    }
}

âœ… 2. ì œê³µ ì¸í„°í˜ì´ìŠ¤ / ìš”êµ¬ ì¸í„°í˜ì´ìŠ¤ = DI (ì˜ì¡´ì„± ì£¼ì…)

    KBSEì—ì„œ ì œê³µ ì¸í„°í˜ì´ìŠ¤ëŠ” ì»´í¬ë„ŒíŠ¸ê°€ "ì´ ê¸°ëŠ¥ í•´ì¤„ê²Œ!"ë¼ê³  ì•½ì†í•œ APIì•¼.

    ìš”êµ¬ ì¸í„°í˜ì´ìŠ¤ëŠ” "ë‚˜ ì´ê±° í•„ìš”í•´!"ë¼ê³  ì™¸ì¹˜ëŠ” ê¸°ëŠ¥ ìš”ì²­ì´ì•¼.

ğŸ‘‰ ìŠ¤í”„ë§ì—ì„œëŠ” ì´ë ‡ê²Œ í‘œí˜„ë¼:

@RestController
public class UserController {
    private final UserService userService;

    // ìš”êµ¬ ì¸í„°í˜ì´ìŠ¤ (UserServiceê°€ í•„ìš”í•´ìš”!)
    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping("/user")
    public String getUser() {
        return userService.getUser(); // ì œê³µ ì¸í„°í˜ì´ìŠ¤ í˜¸ì¶œ
    }
}

âœ… 3. êµì²´ ê°€ëŠ¥ì„± (ìœ ì—°ì„±)

    ğŸ¯ ì»´í¬ë„ŒíŠ¸ë¥¼ ë‹¤ë¥¸ ê²ƒìœ¼ë¡œ êµì²´í•  ìˆ˜ ìˆëŠ” ìœ ì—°ì„± â€” ìŠ¤í”„ë§ì˜ ê°€ì¥ í° ì¥ì  ì¤‘ í•˜ë‚˜ì§€!

ğŸ‘‰ ì˜ˆì‹œ: UserService ëŒ€ì‹  UserApiServiceë¡œ ë°”ê¾¸ê³  ì‹¶ì„ ë•Œ!

public interface UserService {
    String getUser();
}

@Service
public class UserApiService implements UserService {
    public String getUser() {
        return "APIì—ì„œ ê°€ì ¸ì˜¨ ì‚¬ìš©ì";
    }
}

@Configuration
public class AppConfig {
    @Bean
    public UserService userService() {
        return new UserApiService(); // êµ¬í˜„ì²´ êµì²´!
    }
}

ğŸ§  UserControllerëŠ” ì¸í„°í˜ì´ìŠ¤ë§Œ ì•Œê³  ìˆê³  êµ¬í˜„ì²´ëŠ” ëª°ë¼! â†’ ë³€ê²½ì´ ìˆì–´ë„ ì½”ë“œë¥¼ ì•ˆ ê³ ì³ë„ ë¼.
âœ… 4. ë¯¸ë“¤ì›¨ì–´ = ìŠ¤í”„ë§ ì»¨í…Œì´ë„ˆ

    KBSEì—ì„œ ë¯¸ë“¤ì›¨ì–´ëŠ” ì»´í¬ë„ŒíŠ¸ë“¤ì´ ì˜ ì‘ë™í•˜ë„ë¡ ë„ì™€ì£¼ëŠ” í™˜ê²½ì´ë¼ê³  í–ˆì–ì•„?

    ìŠ¤í”„ë§ì—ì„œëŠ” ì´ ì—­í• ì„ ApplicationContext (ìŠ¤í”„ë§ ì»¨í…Œì´ë„ˆ) ê°€ í•´!

ğŸ‘‰ ì˜ˆë¥¼ ë“¤ì–´:

    íŠ¸ëœì­ì…˜ ê´€ë¦¬ (@Transactional)

    ë³´ì•ˆ (Spring Security)

    AOP (@Aspect)

    ë¦¬ì†ŒìŠ¤ ê´€ë¦¬, ë¹ˆ ì£¼ì… ë“±ë“±!

âœ… 5. ì»¨í…Œì´ë„ˆ = ApplicationContext (ë˜ëŠ” IoC ì»¨í…Œì´ë„ˆ)

    KBSEì˜ ì»¨í…Œì´ë„ˆëŠ” ì»´í¬ë„ŒíŠ¸ë¥¼ ì‹¤í–‰ì‹œì¼œì£¼ëŠ” ê³µê°„.

    ìŠ¤í”„ë§ì—ì„œë„ ìš°ë¦¬ê°€ ë§Œë“œëŠ” ëª¨ë“  ë¹ˆë“¤ì´ ì´ ì»¨í…Œì´ë„ˆì—ì„œ ê´€ë¦¬ë¼.

âœ… 6. í…ŒìŠ¤íŠ¸ ìš©ì´ì„±

    DI ë•ë¶„ì— ì›í•˜ëŠ” êµ¬í˜„ì²´ë¡œ êµì²´í•´ì„œ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥!

ğŸ‘‰ ì˜ˆì‹œ:

class MockUserService implements UserService {
    public String getUser() {
        return "í…ŒìŠ¤íŠ¸ ì‚¬ìš©ì";
    }
}

í…ŒìŠ¤íŠ¸ì—ì„œëŠ” ì´ê±¸ ì£¼ì…í•´ì„œ, ì‹¤ì œ DBë‚˜ API ì—†ì´ë„ í…ŒìŠ¤íŠ¸í•  ìˆ˜ ìˆì–´!
