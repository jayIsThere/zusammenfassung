---
title: KBE
author: Jaehan Kim
date: 2025-04-10
category: KBE
layout: post
---

03.04.2025 - Vorlesung 1: Wiederverwendung von Software 1
-------------

### Einf√ºhrung in die Softwarewiederverwendung

- **Definition:** Wiederverwendung bestehender Softwarekomponenten (z. B. Code, Module, Systeme)
- **Motivation:** Geringere Kosten, h√∂here Qualit√§t, schnellere Markteinf√ºhrung
- **Relevanz:** Besonders wichtig seit 2000 durch wachsende Softwarekomplexit√§t und Kostendruck


### Skalierung wiederverwendbarer Softwareeinheiten

- **Systeme von Systemen:** Integration ganzer Systeme
- **Anwendungssysteme:** Konfigurierbare Standardsoftware
- **Anwendungsfamilien / Produktlinien:** Gemeinsame Architektur mit Anpassungsm√∂glichkeiten
- **Komponenten:** Module mittlerer Granularit√§t
- **Objekte und Funktionen:** Kleinste Einheiten, oft in Bibliotheken


### Vorteile der Wiederverwendung

- **Kosten- und Zeitersparnis:** Weniger Entwicklung und Validierung notwendig
- **Zuverl√§ssigkeit:** Durch getestete und bew√§hrte Komponenten
- **Bessere Ressourcennutzung:** Spezialisten und Standards werden besser genutzt
- **Konsistenz und Standardisierung:** Z. B. bei UI-Komponenten


### Probleme der Wiederverwendung

- **Wartungsprobleme:** Unbekannter Quellcode f√ºhrt zu Problemen bei Wartung und Erweiterung
- **Geringe Werkzeugunterst√ºtzung:** Besonders f√ºr eingebettete Systeme
- **‚ÄûNot-invented-here‚Äú-Syndrom:** Widerstand gegen externe Komponenten
- **Aufwand f√ºr Komponentenbibliotheken:** Aufbau und Pflege sind arbeitsintensiv
- **Anpassung erfordert Expertise:** Finden und anpassen von Komponenten ist komplex

---
---
---

10.04.2025 - Vorlesung 2: Wiederverwendung von Software 2
-------------

### Wiederverwendungstechniken (laut Sommerville)

1. **Frameworks**
   - **Definition:** Ein Framework ist ein Set von Softwarekomponenten, das eine Architektur f√ºr verwandte Anwendungen bereitstellt.
   - **Beispiel:** Ein Web-Framework wie Spring MVC verwendet das Model-View-Controller-Muster.
   - **Eigenschaft:** Bietet generische Funktionalit√§t und wird erweitert, nicht ersetzt.

2. **Inversion of Control (IoC)**
   - **Prinzip:** Die Steuerung liegt beim Framework, nicht bei der Anwendung. Die Anwendung registriert ihre Komponenten, und das Framework ruft sie bei Bedarf auf.
   - **Beispiel:** Callbacks in Web-Frameworks.

3. **Entwurfsmuster**
   - **Beispiel:** Observer, Strategy sind g√§ngige Muster, um wiederkehrende Probleme zu l√∂sen.

4. **Architekturmuster**
   - **Beispiel:** Microservices bieten eine systemweite L√∂sung f√ºr komplexe Anwendungen.

5. **ERP-Systeme**
   - **Definition:** Unternehmensweite Systeme mit konfigurierbaren Modulen.
   - **Vorteil:** Bietet L√∂sungen f√ºr die Verwaltung von Gesch√§ftsdaten und Prozessen.

6. **Komponentenbasierte Entwicklung**
   - **Prinzip:** Systeme werden aus austauschbaren Komponenten aufgebaut.

7. **Modellgetriebene Entwicklung**
   - **Definition:** Software wird aus plattformunabh√§ngigen Modellen erstellt.

8. **Serviceorientierte Systeme**
   - **Prinzip:** Nutzung verteilter Webservices (z. B. REST, SOAP) zur Kommunikation zwischen Komponenten.

9. **Softwareproduktlinien**
   - **Definition:** Produktfamilien mit einer gemeinsamen Codebasis und variablen Komponenten.


### Framework-Klassifizierung (nach Fayad & Schmidt)

- **Systeminfrastruktur-Frameworks:** Z. B. Kommunikation, GUI, Compiler
- **Middleware-Integrations-Frameworks:** Z. B. Jakarta EE, .NET f√ºr Komponentenkommunikation
- **Unternehmensanwendungs-Frameworks:** Z. B. spezialisierte Frameworks f√ºr Branchen wie Telekommunikation oder Finanzen.


### Wiederverwendung von Anwendungssystemen

- **Softwareproduktlinien:** Gemeinsamer Kern mit anpassbaren Komponenten
- **Konfigurierbare Systeme:** √úber Parameter anpassbar (z. B. ERP-Systeme)
- **Integrierte Systeme:** Kombination verschiedener Anwendungen √ºber Schnittstellen


### Vorteile und Herausforderungen

- **Vorteile:** Schnellere Bereitstellung und geringeres Entwicklungsrisiko
- **Herausforderungen:** Anpassung an Unternehmensprozesse, fehlende Expertise, Auswahl des richtigen Systems

---
---
---


10.04.2025 - Vorlesung 2: Wiederverwendung von Software 2
-------------

### Grundprinzipien des komponentenbasierten Software-Engineerings ### 

**Unabh√§ngige Komponenten**  
- Vollst√§ndig konfigurierbar √ºber ihre Schnittstellen  
- Schnittstelle klar getrennt von der Implementierung  
- Austauschbar ohne √Ñnderung am System

**Komponentenstandards**  
- Einheitliche Schnittstellendefinition & Integration  
- Umsetzung √ºber Komponentenmodelle, z.‚ÄØB.:
    - Schnittstellenbeschreibung
    - Kommunikationsweise zwischen Komponenten

**Middleware**  
- Serverseitige Unterst√ºtzung f√ºr:
    - Kommunikation verteilter Komponenten
    - Ressourcenmanagement
    - Transaktionsverwaltung, Sicherheit, Parallelit√§t

**Komponentenorientierter Entwicklungsprozess**  
- Anforderungen an vorhandene Komponenten anpassbar  
- Wiederverwendung w√§hrend Planung & Entwicklung


### ‚ö†Ô∏è Probleme & Herausforderungen im KBSE ### 

**Vertrauensw√ºrdigkeit der Komponenten**  
- Blackbox-Natur erschwert Vertrauen  
- Kein Quellcode = wenig Transparenz

**Komponentenzertifizierung**  
- Wer zahlt, wer haftet?  
- Keine klare Verantwortung, rechtlich unsicher

**Vorhersage emergenter Eigenschaften**  
- Integration ‚â† Summe der Einzelteile  
- Unerwartete Seiteneffekte durch Zusammenspiel

**Anforderungskompromisse**  
- Reale Anforderungen vs. Verf√ºgbarkeit  
- Notwendigkeit strukturierter Analysemethoden


### üß© Zentrale Entwurfsprinzipien im KBSE ### 

**Unabh√§ngigkeit**  
- Komponenten beeinflussen sich nicht gegenseitig

**Klar definierte Schnittstellen**  
- Austauschbar bei stabiler API

**Komponenteninfrastruktur mit Standarddiensten**  
- Weniger Neuentwicklung n√∂tig  
- Fokus auf Integration statt Eigenentwicklung


### Komponenten als Dienstanbieter ### 

- Komponenten stellen Dienste bereit und kapseln deren Implementierung.
- Aufgerufen vom System, ohne zu wissen:
    - Wo sie ausgef√ºhrt werden
    - In welcher Sprache sie geschrieben sind

**Vorteile**  
- Unabh√§ngig & ausf√ºhrbar √ºber ihre Schnittstelle
- Schnittstellenbasiert ‚Üí kein Zugriff auf internen Zustand n√∂tig


###  üîç Komponenten vs. Objekte ### 

| Merkmal                | Komponente                     | Objekt                          |
|------------------------|--------------------------------|---------------------------------|
| **Deployment**          | Direkt auf Plattform installierbar | Teil eines Programms (kompiliert) |
| **Typdefinition**       | Ist eine Instanz               | Basierend auf Klasse (Typ)     |
| **Transparenz**         | Blackbox, Schnittstelle-only   | Oft transparenter               |
| **Sprachabh√§ngigkeit**  | Sprachunabh√§ngig               | Sprachgebunden (z. B. nur Java) |
| **Standardisierung**    | Muss Komponentenmodell folgen  | Frei definierbar                |


### üß© Komponentenschnittstellen ### 

**Stellt bereit (provided interface)**  
- API der Komponente ‚Äì was sie bietet

**Ben√∂tigt (required interface)**  
- Welche Dienste sie selbst braucht, um korrekt zu funktionieren  
- Definiert nicht, wie diese bereitgestellt werden


### üéØ Visualisierung in UML (kompakt) ### 

üß± **Komponente**  
- Wird mit Rechteck + 2 kleinen Rechtecken dargestellt
- Enth√§lt:
    - Realisierungsklassen
    - "Stellt bereit"- und "Ben√∂tigt"-Schnittstellen (sichtbar an Port-Notationen)


### Schnittstellenspezifikation in Komponentenmodellen ### 

- Komponenten werden √ºber ihre Schnittstellen definiert
- Das Komponentenmodell regelt:
    - Wie Schnittstellen aufgebaut sind
    - In welcher Sprache sie beschrieben werden

**Beispiele**  
- SOAP Webservices ‚Üí WSDL (XML)
- Jakarta Beans / CDI ‚Üí Java
- Microsoft .NET ‚Üí CIL


### üß© Grundelemente eines Komponentenmodells ### 

| Element              | Beschreibung                                                        |
|----------------------|---------------------------------------------------------------------|
| **Schnittstellen**    | Bereitgestellte + ben√∂tigte Dienste                                  |
| **Nutzung**           | Globale Bezeichner/Handles (z.‚ÄØB. URI, JNDI)                         |
| **Bereitstellung & Verpackung** | inkl. Konfigurationsoptionen, Doku, Meta-Infos           |
| **Komposition**       | Wie Komponenten zusammengebaut werden                                |
| **Anpassung**         | Konfigurierbar f√ºr konkrete Einsatzszenarien                         |
| **Evolution**         | Austausch- und Update-Regeln                                          |
| **Dokumentation & Namenskonvention** | Strukturierter Zugriff & √úbersicht                      |

**Metadatenzugriff**  
- z.‚ÄØB. via Reflection (Java)


### ‚öôÔ∏è Bereitstellung & Anpassung ### 

- Komponenten sind unabh√§ngig lauff√§hig
- M√ºssen komplett mit ben√∂tigter Infrastruktur geliefert werden
- Doku & Austauschregeln sind Teil des Modells
- Unterst√ºtzung f√ºr Konfigurierbarkeit & Wiederverwendbarkeit


### üõ†Ô∏è Middleware-Dienste im Komponentenmodell ### 

**Zwei Kategorien:**  
1. **Plattformdienste**  
    (grundlegend f√ºr verteilte Kommunikation)
    - Komponentenkommunikation
    - Ressourcenverwaltung
    - Adressierung
    - Ausnahmebehandlung
    - Transaktionsverwaltung
    - Informationssicherheit
    - Persistenz
    - Nebenl√§ufigkeit

2. **Hilfsdienste**  
    (erg√§nzend, z.‚ÄØB. Authentifizierung)
    - Entlasten die Entwicklung, verhindern Inkompatibilit√§ten


### üßÉ Container als Laufzeitumgebung ### 

- **Container** = Laufzeitumgebung mit Middleware-Diensten
- Besteht aus:
    - Dienstimplementierungen
    - Definitionen f√ºr Schnittstellenintegration

**Effekt:**  
- Komponente nutzt Containerdienste √ºber bereitgestellte Schnittstelle  
- Kommunikation mit anderen Komponenten l√§uft indirekt √ºber Proxys

**Beispiel:**  
- EJB-Container (m√§chtig, komplex)
- Spring Framework (leichtgewichtig, effizienter)

---
---
---


√úbungsblatt
-------------

#### √úbungsblatt 1

### Aufgabe 1. Grundstrategie des Software-Engineerings

**Ziel der Wiederverwendung**:  
- Wiederverwendung vorhandener Software, statt neue Software von Grund auf zu entwickeln.


### Aufgabe 2. Aspekte, die den Ansatz getrieben haben:

- Geringere Produktions- und Wartungskosten
- Schnellere Auslieferung von Systemen
- H√∂here Softwarequalit√§t


### Aufgabe 3. Beispiele f√ºr etablierte wiederverwendbare Software:

- Open Source Code (z.‚ÄØB. Apache Commons)
- ERP-Systeme (z.‚ÄØB. SAP)
- Komponentenbibliotheken
- Webservices (z.‚ÄØB. PayPal)


### Aufgabe 4. Gr√∂√üenordnungen von Softwareeinheiten (von gro√ü nach klein):

- Systeme
- Anwendungen
- Softwareproduktlinien
- Komponenten
- Objekte und Funktionen


### Aufgabe 5. Beispiele f√ºr jede Gr√∂√üenordnung:

- **System**: Ein ERP-System, z.‚ÄØB. SAP
- **Anwendung**: Ein CRM-System
- **Produktlinie**: Softwarelinie f√ºr medizinische Ger√§te
- **Komponente**: Zahlungsmodul
- **Funktion/Objekt**: Logging-Klasse aus Apache Commons


### Aufgabe 6. Vorteile der Wiederverwendung:

- Geringere Kosten
- H√∂here Zuverl√§ssigkeit
- Geringeres Entwicklungsrisiko
- Schnellere Markteinf√ºhrung
- Effektiver Einsatz von Experten
- Standardkonformit√§t


### Aufgabe 6. Probleme der Wiederverwendung:

- H√∂here Wartungskosten
- Mangel an Werkzeugunterst√ºtzung
- "Not-invented-here"-Syndrom
- Hoher Aufwand f√ºr Bibliotheksverwaltung
- Schwierige Suche und Anpassung von Komponenten


### Aufgabe 7. Planung der Wiederverwendung

**Vier Schl√ºsselfaktoren:**

- Entwicklungszeitplan
- Erwartete Lebensdauer der Software
- Erfahrung des Entwicklerteams
- Wichtigkeit/Nicht-funktionale Anforderungen


### Aufgabe 8. Schl√ºsselfaktoren bei .NET und schneller Verf√ºgbarkeit:

- Plattformabh√§ngigkeit (‚Üí .NET-Kompatibilit√§t)
- Geringer Entwicklungsaufwand durch Wiederverwendung fertiger Systeme


### Aufgabe 9-12. Anwendungsframeworks

**Attribute von Frameworks:**

| Attribut | Passt? |
|----------|--------|
| Konfigurierbar | ‚úÖ Ja |
| Generisch | ‚úÖ Ja |
| Call-back | ‚úÖ Ja |
| Unterst√ºtzung konkreter Gesch√§ftsaktivit√§ten | ‚úÖ Ja |
| Inversion of Control | ‚úÖ Ja |
| Inh√§rent erweiterbar | ‚úÖ Ja |
| Basis sehr √§hnlicher Systeme | ‚úÖ Ja |
| Unterst√ºtzung f√ºr Hardware-Schnittstellen | ‚ùå Teilweise (meist Software) |
| Immer objektorientiert | ‚ùå Nein (meist, aber nicht zwingend) |

**Drei Architektur- und Entwurfsmuster, auf denen WAFs basieren:**

- Model-View-Controller (MVC)
- Observer Pattern
- Strategy Pattern (auch Composite Pattern m√∂glich)

**Funktion von WAFs oder Entwicklern:**

| Funktion | WAF | ENT |
|----------|-----|-----|
| Zahlungstransaktion √ºber Kreditkarte durchf√ºhren |  | ‚úÖ |
| Verwaltung des Inhalts eines Shop-Warenkorbs | ‚úÖ |  |
| Abfragedaten in einer Tabelle aufbereiten | ‚úÖ |  |
| Am System anmelden und abmelden | ‚úÖ |  |
| Zugriff auf ein Geoinformationsdienst |  | ‚úÖ |
| Bestimmung des aktuellen Standorts √ºber GPS |  | ‚úÖ |
| Asynchrone Aktualisierung durch Auswahl eines Listeneintrags | ‚úÖ |  |
| Ge√§nderte Daten nach dem Speichern sichtbar machen | ‚úÖ |  |
| Ermittlung verschiedener Bahn-Routen |  | ‚úÖ |
| Nutzung einer 3D-Spiele-Engine |  | ‚úÖ |
| Gesch√§ftsdaten persistieren | ‚úÖ |  |

**Unterschied Framework vs. Bibliothek:**

- Bei **Bibliotheken** ruft die Anwendung die Bibliothek auf.
- Bei **Frameworks** ruft das Framework die Anwendung auf.
    - ‚Üí Inversion of Control (IoC, ‚ÄûHollywood Principle‚Äú: "Don't call us, we'll call you")


### Aufgabe 13-15. Softwareproduktlinien

**Was ist eine Softwareproduktlinie und wann ist sie effizient?**  
- Eine Produktlinie ist ein Satz verwandter Anwendungen mit gemeinsamer Architektur.
- Effizient, wenn viele √§hnliche, aber nicht identische Systeme ben√∂tigt werden.

**Aufbau des Basissystems:**

- Kernkomponenten (nicht ver√§nderbar)
- Konfigurierbare Komponenten
- Spezielle Anwendungskomponenten

**Voraussetzung bei Nutzung von Frameworks f√ºr Produktlinien:**

- Das Framework muss erweiterbar und anpassbar sein, um dom√§nenspezifische Komponenten einzubetten.

### Aufgabe 16-19. Anwendungssysteme

**Welche Aussagen √ºber Anwendungssysteme sind korrekt?**

| Aussage | Ja |
|---------|-----|
| Lassen sich viel schneller zuverl√§ssig bereitstellen | ‚úÖ |
| Sind im Kern sehr gut auf kundenspezifische Bed√ºrfnisse zugeschnitten | ‚ùå |
| Support-Ratschl√§ge = Verkaufsfokus, nicht Bedarfsermittlung | ‚úÖ |
| Gut zur Abbildung bestehender Gesch√§ftsprozesse geeignet | ‚úÖ |
| Anpassbar ohne Quellcode-√Ñnderung | ‚úÖ |
| Technologie-Updates = Verantwortung des Herstellers | ‚úÖ |
| F√ºr Unternehmen mit √§hnlichen Systemanforderungen geeignet | ‚úÖ |

**Zwei Ans√§tze von Anwendungssystemen:**

- **Konfigurierbare Anwendungssysteme**: Einzelprodukt, Konfiguration
- **Integration von Anwendungssystemen**: Mehrere Systeme, Anpassung durch Integration

**Zuordnung der Aussagen:**

| Aussage | Ansatz |
|---------|--------|
| Schwerpunkt: Systemintegration | 2 |
| Systemanbieter liefert Plattform | 1 |
| Einzelprodukt liefert ben√∂tigte Funktionalit√§t | 1 |
| Entwicklung flexibler L√∂sungen f√ºr Kundenprozesse | 2 |
| System basiert auf generischer L√∂sung und standardisierten Prozessen | 1 |
| Wartung = Verantwortung des Systembesitzers | 2 |

**Beispielsysteme f√ºr beide Ans√§tze:**

- **Konfigurierbares Anwendungssystem**: SAP ERP
- **Integriertes Anwendungssystem**: E-Commerce-System mit ERP- und E-Mail-Anbindung

---
---
---

#### √úbungsblatt 2

### Aufgabe 1. Beweggr√ºnde f√ºr die Entstehung des Komponentenbasierten Software-Engineerings

**Wiederverwendbarkeit**:  
- Softwarekomponenten k√∂nnen wiederverwendet werden, was Entwicklungszeit und Kosten spart.

**Modularit√§t**:  
- Komponenten sind unabh√§ngig, was Wartung und Erweiterung vereinfacht.

**Flexibilit√§t**:  
- Komponenten k√∂nnen ausgetauscht werden, ohne das gesamte System zu √§ndern.

**Skalierbarkeit**:  
- Komponenten k√∂nnen unabh√§ngig skaliert und optimiert werden.


### Aufgabe 2. Vier Grundlagen des Komponentenbasierten Software-Engineerings

**Unabh√§ngige Komponenten**:  
- Komponenten k√∂nnen ohne System√§nderungen ausgetauscht werden.

**Komponentenstandards**:  
- Einheitliche Schnittstellen und Integrationen sind wichtig.

**Middleware**:  
- Unterst√ºtzung f√ºr Kommunikation, Ressourcenmanagement, Transaktionen, Sicherheit und Parallelit√§t.

**Komponentenorientierter Entwicklungsprozess**:  
- Komponenten k√∂nnen w√§hrend der Planung und Entwicklung angepasst und wiederverwendet werden.


### Aufgabe 3. Probleme der Vertrauensw√ºrdigkeit von Komponenten

**Blackbox-Natur**:  
- Quellcode nicht verf√ºgbar, schwierige Transparenz.

**Kein Zugriff auf den Quellcode**:  
- Es ist schwierig, Fehler zu erkennen.

**Unerwartete Seiteneffekte**:  
- Das Zusammenspiel von Komponenten kann unvorhergesehene Probleme verursachen.


### Aufgabe 4. Drei grundlegende Entwurfsprinzipien des Komponentenbasierten Software-Engineerings

**Unabh√§ngigkeit**:  
- Komponenten beeinflussen sich nicht gegenseitig.

**Klar definierte Schnittstellen**:  
- Stabiler API-Austausch m√∂glich.

**Komponenteninfrastruktur mit Standarddiensten**:  
- Weniger Eigenentwicklung notwendig, Fokus auf Integration.


### Aufgabe 5. Eigenschaften von Komponenten (Sommerville)

**Unabh√§ngigkeit**:  
- Komponenten sind autonome Einheiten.

**Modularit√§t**:  
- Komponenten sind isolierte Einheiten, die unabh√§ngig entwickelt werden k√∂nnen.

**Wiederverwendbarkeit**:  
- Komponenten k√∂nnen in verschiedenen Systemen verwendet werden.

**Dienstanbieter**:  
- Komponenten bieten Dienste, ohne dass der Benutzer den internen Zustand kennt.


### Aufgabe 6. Kritische Vorteile der Betrachtung einer Komponente als Dienstanbieter

**Unabh√§ngigkeit**:  
- Komponenten werden √ºber Schnittstellen aufgerufen und sind nicht von der Umgebung abh√§ngig.

**Sprachunabh√§ngigkeit**:  
- Komponenten k√∂nnen in verschiedenen Programmiersprachen implementiert werden.


### Aufgabe 7. Unterschiede zwischen Komponenten und Objekten

| Merkmal              | Komponente                        | Objekt                         |
|----------------------|-----------------------------------|--------------------------------|
| **Deployment**        | Direkt auf Plattform installierbar | Teil eines Programms (kompiliert) |
| **Typdefinition**     | Instanz                           | Basierend auf Klasse (Typ)    |
| **Transparenz**       | Blackbox (nur Schnittstelle sichtbar) | Oft transparenter (mehr Einblick) |
| **Sprachabh√§ngigkeit**| Sprachunabh√§ngig                  | Sprachgebunden (z. B. Java)    |
| **Standardisierung**  | Muss Modell folgen                | Frei definierbar               |


### Aufgabe 8. Unterschiedliche Schnittstellen von Komponenten

**Bereitgestellte Schnittstelle (provided interface)**:  
- Definiert die Dienste, die von der Komponente angeboten werden.

**Ben√∂tigte Schnittstelle (required interface)**:  
- Definiert, welche Dienste die Komponente ben√∂tigt, ohne zu spezifizieren, wie sie bereitgestellt werden.


### Aufgabe 8. UML-Diagramm

---


### Aufgabe 10. UML-Darstellung der ‚ÄûDataBroker‚Äú-Komponente

- Eine Komponente wird durch ein Rechteck dargestellt, das die Schnittstellen und die dazugeh√∂rigen ‚Äûbereitgestellten‚Äú und ‚Äûben√∂tigten‚Äú Schnittstellen (mit kleinen Rechtecken) enth√§lt.


### Aufgabe 11. Prinzip eines Komponentenmodells

**Prinzip**:  
- Ein Komponentenmodell definiert, wie Komponenten strukturiert, interagieren und konfiguriert werden.

**Beispiele**:  
- SOAP (WSDL), Jakarta Beans (CDI), Microsoft .NET (CIL).


### Aufgabe 12. Drei allgemeine Aspekte der Grundelemente eines Komponentenmodells

**Schnittstellen**:  
- Definiert die bereitgestellten und ben√∂tigten Dienste.

**Nutzung**:  
- Globale Bezeichner (z. B. URI, JNDI).

**Bereitstellung & Verpackung**:  
- Konfiguration, Dokumentation und Meta-Informationen.


### Aufgabe 13. Unterschied zwischen Plattform- und Hilfsdiensten einer Middleware

**Plattformdienste**:  
- Grundlegende Funktionen wie Kommunikation, Ressourcenverwaltung, Transaktionen, Persistenz.

**Hilfsdienste**:  
- Erg√§nzende Dienste wie Authentifizierung, die Inkompatibilit√§ten verhindern.


### Aufgabe 14. Implementierung eines Komponentenmodells

**Container**:  
- Eine Laufzeitumgebung, die Middleware-Dienste f√ºr die Ausf√ºhrung von Komponenten bereitstellt.


### Aufgabe 15. Aussagen zu Containern und Komponenten

| Aussage                                                         | Ja/Nein |
|-----------------------------------------------------------------|---------|
| Ein Container ist die Hauptkomponente jeder Applikation         | Nein    |
| Eine Komponente kann auf den Transaktionsdienst zugreifen      | Ja      |
| Der Container erm√∂glicht, dass Komponente A auf die Schnittstelle von B zugreifen kann | Ja      |
| Komponenten sind Hilfsdienste des Containers                    | Nein    |
| Der Container kann auf Komponentenschnittstellen zugreifen      | Nein    |
| Die Adressierung von Komponenten ist ein Hilfsdienst des Containers | Ja      |

---
---
---
#### √úbungsblatt 3
#### √úbungsblatt 4


