---
title: KBE
author: Jaehan Kim
date: 2025-04-10
category: KBE
layout: post
---

03.04.2025 - Vorlesung 1: Wiederverwendung von Software 1
-------------

### Einf√ºhrung in die Softwarewiederverwendung

- **Definition:** Wiederverwendung bestehender Softwarekomponenten (z. B. Code, Module, Systeme)
- **Motivation:** Geringere Kosten, h√∂here Qualit√§t, schnellere Markteinf√ºhrung
- **Relevanz:** Besonders wichtig seit 2000 durch wachsende Softwarekomplexit√§t und Kostendruck


### Skalierung wiederverwendbarer Softwareeinheiten

- **Systeme von Systemen:** Integration ganzer Systeme
- **Anwendungssysteme:** Konfigurierbare Standardsoftware
- **Anwendungsfamilien / Produktlinien:** Gemeinsame Architektur mit Anpassungsm√∂glichkeiten
- **Komponenten:** Module mittlerer Granularit√§t
- **Objekte und Funktionen:** Kleinste Einheiten, oft in Bibliotheken


### Vorteile der Wiederverwendung

- **Kosten- und Zeitersparnis:** Weniger Entwicklung und Validierung notwendig
- **Zuverl√§ssigkeit:** Durch getestete und bew√§hrte Komponenten
- **Bessere Ressourcennutzung:** Spezialisten und Standards werden besser genutzt
- **Konsistenz und Standardisierung:** Z. B. bei UI-Komponenten


### Probleme der Wiederverwendung

- **Wartungsprobleme:** Unbekannter Quellcode f√ºhrt zu Problemen bei Wartung und Erweiterung
- **Geringe Werkzeugunterst√ºtzung:** Besonders f√ºr eingebettete Systeme
- **‚ÄûNot-invented-here‚Äú-Syndrom:** Widerstand gegen externe Komponenten
- **Aufwand f√ºr Komponentenbibliotheken:** Aufbau und Pflege sind arbeitsintensiv
- **Anpassung erfordert Expertise:** Finden und anpassen von Komponenten ist komplex

---
---
---

10.04.2025 - Vorlesung 2: Wiederverwendung von Software 2
-------------

### Wiederverwendungstechniken (laut Sommerville)

1. **Frameworks**
   - **Definition:** Ein Framework ist ein Set von Softwarekomponenten, das eine Architektur f√ºr verwandte Anwendungen bereitstellt.
   - **Beispiel:** Ein Web-Framework wie Spring MVC verwendet das Model-View-Controller-Muster.
   - **Eigenschaft:** Bietet generische Funktionalit√§t und wird erweitert, nicht ersetzt.

2. **Inversion of Control (IoC)**
   - **Prinzip:** Die Steuerung liegt beim Framework, nicht bei der Anwendung. Die Anwendung registriert ihre Komponenten, und das Framework ruft sie bei Bedarf auf.
   - **Beispiel:** Callbacks in Web-Frameworks.

3. **Entwurfsmuster**
   - **Beispiel:** Observer, Strategy sind g√§ngige Muster, um wiederkehrende Probleme zu l√∂sen.

4. **Architekturmuster**
   - **Beispiel:** Microservices bieten eine systemweite L√∂sung f√ºr komplexe Anwendungen.

5. **ERP-Systeme**
   - **Definition:** Unternehmensweite Systeme mit konfigurierbaren Modulen.
   - **Vorteil:** Bietet L√∂sungen f√ºr die Verwaltung von Gesch√§ftsdaten und Prozessen.

6. **Komponentenbasierte Entwicklung**
   - **Prinzip:** Systeme werden aus austauschbaren Komponenten aufgebaut.

7. **Modellgetriebene Entwicklung**
   - **Definition:** Software wird aus plattformunabh√§ngigen Modellen erstellt.

8. **Serviceorientierte Systeme**
   - **Prinzip:** Nutzung verteilter Webservices (z. B. REST, SOAP) zur Kommunikation zwischen Komponenten.

9. **Softwareproduktlinien**
   - **Definition:** Produktfamilien mit einer gemeinsamen Codebasis und variablen Komponenten.


### Framework-Klassifizierung (nach Fayad & Schmidt)

- **Systeminfrastruktur-Frameworks:** Z. B. Kommunikation, GUI, Compiler
- **Middleware-Integrations-Frameworks:** Z. B. Jakarta EE, .NET f√ºr Komponentenkommunikation
- **Unternehmensanwendungs-Frameworks:** Z. B. spezialisierte Frameworks f√ºr Branchen wie Telekommunikation oder Finanzen.


### Wiederverwendung von Anwendungssystemen

- **Softwareproduktlinien:** Gemeinsamer Kern mit anpassbaren Komponenten
- **Konfigurierbare Systeme:** √úber Parameter anpassbar (z. B. ERP-Systeme)
- **Integrierte Systeme:** Kombination verschiedener Anwendungen √ºber Schnittstellen


### Vorteile und Herausforderungen

- **Vorteile:** Schnellere Bereitstellung und geringeres Entwicklungsrisiko
- **Herausforderungen:** Anpassung an Unternehmensprozesse, fehlende Expertise, Auswahl des richtigen Systems

---
---
---


10.04.2025 - Vorlesung 2: Wiederverwendung von Software 2
-------------

### Grundprinzipien des komponentenbasierten Software-Engineerings ### 

**Unabh√§ngige Komponenten**  
- Vollst√§ndig konfigurierbar √ºber ihre Schnittstellen  
- Schnittstelle klar getrennt von der Implementierung  
- Austauschbar ohne √Ñnderung am System

**Komponentenstandards**  
- Einheitliche Schnittstellendefinition & Integration  
- Umsetzung √ºber Komponentenmodelle, z.‚ÄØB.:
    - Schnittstellenbeschreibung
    - Kommunikationsweise zwischen Komponenten

**Middleware**  
- Serverseitige Unterst√ºtzung f√ºr:
    - Kommunikation verteilter Komponenten
    - Ressourcenmanagement
    - Transaktionsverwaltung, Sicherheit, Parallelit√§t

**Komponentenorientierter Entwicklungsprozess**  
- Anforderungen an vorhandene Komponenten anpassbar  
- Wiederverwendung w√§hrend Planung & Entwicklung


### ‚ö†Ô∏è Probleme & Herausforderungen im KBSE ### 

**Vertrauensw√ºrdigkeit der Komponenten**  
- Blackbox-Natur erschwert Vertrauen  
- Kein Quellcode = wenig Transparenz

**Komponentenzertifizierung**  
- Wer zahlt, wer haftet?  
- Keine klare Verantwortung, rechtlich unsicher

**Vorhersage emergenter Eigenschaften**  
- Integration ‚â† Summe der Einzelteile  
- Unerwartete Seiteneffekte durch Zusammenspiel

**Anforderungskompromisse**  
- Reale Anforderungen vs. Verf√ºgbarkeit  
- Notwendigkeit strukturierter Analysemethoden


### üß© Zentrale Entwurfsprinzipien im KBSE ### 

**Unabh√§ngigkeit**  
- Komponenten beeinflussen sich nicht gegenseitig

**Klar definierte Schnittstellen**  
- Austauschbar bei stabiler API

**Komponenteninfrastruktur mit Standarddiensten**  
- Weniger Neuentwicklung n√∂tig  
- Fokus auf Integration statt Eigenentwicklung


### Komponenten als Dienstanbieter ### 

- Komponenten stellen Dienste bereit und kapseln deren Implementierung.
- Aufgerufen vom System, ohne zu wissen:
    - Wo sie ausgef√ºhrt werden
    - In welcher Sprache sie geschrieben sind

**Vorteile**  
- Unabh√§ngig & ausf√ºhrbar √ºber ihre Schnittstelle
- Schnittstellenbasiert ‚Üí kein Zugriff auf internen Zustand n√∂tig


###  üîç Komponenten vs. Objekte ### 

| Merkmal                | Komponente                     | Objekt                          |
|------------------------|--------------------------------|---------------------------------|
| **Deployment**          | Direkt auf Plattform installierbar | Teil eines Programms (kompiliert) |
| **Typdefinition**       | Ist eine Instanz               | Basierend auf Klasse (Typ)     |
| **Transparenz**         | Blackbox, Schnittstelle-only   | Oft transparenter               |
| **Sprachabh√§ngigkeit**  | Sprachunabh√§ngig               | Sprachgebunden (z. B. nur Java) |
| **Standardisierung**    | Muss Komponentenmodell folgen  | Frei definierbar                |


### üß© Komponentenschnittstellen ### 

**Stellt bereit (provided interface)**  
- API der Komponente ‚Äì was sie bietet

**Ben√∂tigt (required interface)**  
- Welche Dienste sie selbst braucht, um korrekt zu funktionieren  
- Definiert nicht, wie diese bereitgestellt werden


### üéØ Visualisierung in UML (kompakt) ### 

üß± **Komponente**  
- Wird mit Rechteck + 2 kleinen Rechtecken dargestellt
- Enth√§lt:
    - Realisierungsklassen
    - "Stellt bereit"- und "Ben√∂tigt"-Schnittstellen (sichtbar an Port-Notationen)


### Schnittstellenspezifikation in Komponentenmodellen ### 

- Komponenten werden √ºber ihre Schnittstellen definiert
- Das Komponentenmodell regelt:
    - Wie Schnittstellen aufgebaut sind
    - In welcher Sprache sie beschrieben werden

**Beispiele**  
- SOAP Webservices ‚Üí WSDL (XML)
- Jakarta Beans / CDI ‚Üí Java
- Microsoft .NET ‚Üí CIL


### üß© Grundelemente eines Komponentenmodells ### 

| Element              | Beschreibung                                                        |
|----------------------|---------------------------------------------------------------------|
| **Schnittstellen**    | Bereitgestellte + ben√∂tigte Dienste                                  |
| **Nutzung**           | Globale Bezeichner/Handles (z.‚ÄØB. URI, JNDI)                         |
| **Bereitstellung & Verpackung** | inkl. Konfigurationsoptionen, Doku, Meta-Infos           |
| **Komposition**       | Wie Komponenten zusammengebaut werden                                |
| **Anpassung**         | Konfigurierbar f√ºr konkrete Einsatzszenarien                         |
| **Evolution**         | Austausch- und Update-Regeln                                          |
| **Dokumentation & Namenskonvention** | Strukturierter Zugriff & √úbersicht                      |

**Metadatenzugriff**  
- z.‚ÄØB. via Reflection (Java)


### ‚öôÔ∏è Bereitstellung & Anpassung ### 

- Komponenten sind unabh√§ngig lauff√§hig
- M√ºssen komplett mit ben√∂tigter Infrastruktur geliefert werden
- Doku & Austauschregeln sind Teil des Modells
- Unterst√ºtzung f√ºr Konfigurierbarkeit & Wiederverwendbarkeit


### üõ†Ô∏è Middleware-Dienste im Komponentenmodell ### 

**Zwei Kategorien:**  
1. **Plattformdienste**  
    (grundlegend f√ºr verteilte Kommunikation)
    - Komponentenkommunikation
    - Ressourcenverwaltung
    - Adressierung
    - Ausnahmebehandlung
    - Transaktionsverwaltung
    - Informationssicherheit
    - Persistenz
    - Nebenl√§ufigkeit

2. **Hilfsdienste**  
    (erg√§nzend, z.‚ÄØB. Authentifizierung)
    - Entlasten die Entwicklung, verhindern Inkompatibilit√§ten


### üßÉ Container als Laufzeitumgebung ### 

- **Container** = Laufzeitumgebung mit Middleware-Diensten
- Besteht aus:
    - Dienstimplementierungen
    - Definitionen f√ºr Schnittstellenintegration

**Effekt:**  
- Komponente nutzt Containerdienste √ºber bereitgestellte Schnittstelle  
- Kommunikation mit anderen Komponenten l√§uft indirekt √ºber Proxys

**Beispiel:**  
- EJB-Container (m√§chtig, komplex)
- Spring Framework (leichtgewichtig, effizienter)

---
---
---


√úbungsblatt 1
-------------

### Aufgabe 1. Grundstrategie des Software-Engineerings

**Ziel der Wiederverwendung**:  
- Wiederverwendung vorhandener Software, statt neue Software von Grund auf zu entwickeln.


### Aufgabe 2. Aspekte, die den Ansatz getrieben haben:

- Geringere Produktions- und Wartungskosten
- Schnellere Auslieferung von Systemen
- H√∂here Softwarequalit√§t


### Aufgabe 3. Beispiele f√ºr etablierte wiederverwendbare Software:

- Open Source Code (z.‚ÄØB. Apache Commons)
- ERP-Systeme (z.‚ÄØB. SAP)
- Komponentenbibliotheken
- Webservices (z.‚ÄØB. PayPal)


### Aufgabe 4. Gr√∂√üenordnungen von Softwareeinheiten (von gro√ü nach klein):

- Systeme
- Anwendungen
- Softwareproduktlinien
- Komponenten
- Objekte und Funktionen


### Aufgabe 5. Beispiele f√ºr jede Gr√∂√üenordnung:

- **System**: Ein ERP-System, z.‚ÄØB. SAP
- **Anwendung**: Ein CRM-System
- **Produktlinie**: Softwarelinie f√ºr medizinische Ger√§te
- **Komponente**: Zahlungsmodul
- **Funktion/Objekt**: Logging-Klasse aus Apache Commons


### Aufgabe 6. Vorteile der Wiederverwendung:

- Geringere Kosten
- H√∂here Zuverl√§ssigkeit
- Geringeres Entwicklungsrisiko
- Schnellere Markteinf√ºhrung
- Effektiver Einsatz von Experten
- Standardkonformit√§t


### Aufgabe 6. Probleme der Wiederverwendung:

- H√∂here Wartungskosten
- Mangel an Werkzeugunterst√ºtzung
- "Not-invented-here"-Syndrom
- Hoher Aufwand f√ºr Bibliotheksverwaltung
- Schwierige Suche und Anpassung von Komponenten


### Aufgabe 7. Planung der Wiederverwendung

**Vier Schl√ºsselfaktoren:**

- Entwicklungszeitplan
- Erwartete Lebensdauer der Software
- Erfahrung des Entwicklerteams
- Wichtigkeit/Nicht-funktionale Anforderungen


### Aufgabe 8. Schl√ºsselfaktoren bei .NET und schneller Verf√ºgbarkeit:

- Plattformabh√§ngigkeit (‚Üí .NET-Kompatibilit√§t)
- Geringer Entwicklungsaufwand durch Wiederverwendung fertiger Systeme


### Aufgabe 9-12. Anwendungsframeworks

**Attribute von Frameworks:**

| Attribut | Passt? |
|----------|--------|
| Konfigurierbar | ‚úÖ Ja |
| Generisch | ‚úÖ Ja |
| Call-back | ‚úÖ Ja |
| Unterst√ºtzung konkreter Gesch√§ftsaktivit√§ten | ‚úÖ Ja |
| Inversion of Control | ‚úÖ Ja |
| Inh√§rent erweiterbar | ‚úÖ Ja |
| Basis sehr √§hnlicher Systeme | ‚úÖ Ja |
| Unterst√ºtzung f√ºr Hardware-Schnittstellen | ‚ùå Teilweise (meist Software) |
| Immer objektorientiert | ‚ùå Nein (meist, aber nicht zwingend) |

**Drei Architektur- und Entwurfsmuster, auf denen WAFs basieren:**

- Model-View-Controller (MVC)
- Observer Pattern
- Strategy Pattern (auch Composite Pattern m√∂glich)

**Funktion von WAFs oder Entwicklern:**

| Funktion | WAF | ENT |
|----------|-----|-----|
| Zahlungstransaktion √ºber Kreditkarte durchf√ºhren |  | ‚úÖ |
| Verwaltung des Inhalts eines Shop-Warenkorbs | ‚úÖ |  |
| Abfragedaten in einer Tabelle aufbereiten | ‚úÖ |  |
| Am System anmelden und abmelden | ‚úÖ |  |
| Zugriff auf ein Geoinformationsdienst |  | ‚úÖ |
| Bestimmung des aktuellen Standorts √ºber GPS |  | ‚úÖ |
| Asynchrone Aktualisierung durch Auswahl eines Listeneintrags | ‚úÖ |  |
| Ge√§nderte Daten nach dem Speichern sichtbar machen | ‚úÖ |  |
| Ermittlung verschiedener Bahn-Routen |  | ‚úÖ |
| Nutzung einer 3D-Spiele-Engine |  | ‚úÖ |
| Gesch√§ftsdaten persistieren | ‚úÖ |  |

**Unterschied Framework vs. Bibliothek:**

- Bei **Bibliotheken** ruft die Anwendung die Bibliothek auf.
- Bei **Frameworks** ruft das Framework die Anwendung auf.
    - ‚Üí Inversion of Control (IoC, ‚ÄûHollywood Principle‚Äú: "Don't call us, we'll call you")


### Aufgabe 13-15. Softwareproduktlinien

**Was ist eine Softwareproduktlinie und wann ist sie effizient?**  
- Eine Produktlinie ist ein Satz verwandter Anwendungen mit gemeinsamer Architektur.
- Effizient, wenn viele √§hnliche, aber nicht identische Systeme ben√∂tigt werden.

**Aufbau des Basissystems:**

- Kernkomponenten (nicht ver√§nderbar)
- Konfigurierbare Komponenten
- Spezielle Anwendungskomponenten

**Voraussetzung bei Nutzung von Frameworks f√ºr Produktlinien:**

- Das Framework muss erweiterbar und anpassbar sein, um dom√§nenspezifische Komponenten einzubetten.

### Aufgabe 16-19. Anwendungssysteme

**Welche Aussagen √ºber Anwendungssysteme sind korrekt?**

| Aussage | Ja |
|---------|-----|
| Lassen sich viel schneller zuverl√§ssig bereitstellen | ‚úÖ |
| Sind im Kern sehr gut auf kundenspezifische Bed√ºrfnisse zugeschnitten | ‚ùå |
| Support-Ratschl√§ge = Verkaufsfokus, nicht Bedarfsermittlung | ‚úÖ |
| Gut zur Abbildung bestehender Gesch√§ftsprozesse geeignet | ‚úÖ |
| Anpassbar ohne Quellcode-√Ñnderung | ‚úÖ |
| Technologie-Updates = Verantwortung des Herstellers | ‚úÖ |
| F√ºr Unternehmen mit √§hnlichen Systemanforderungen geeignet | ‚úÖ |

**Zwei Ans√§tze von Anwendungssystemen:**

- **Konfigurierbare Anwendungssysteme**: Einzelprodukt, Konfiguration
- **Integration von Anwendungssystemen**: Mehrere Systeme, Anpassung durch Integration

**Zuordnung der Aussagen:**

| Aussage | Ansatz |
|---------|--------|
| Schwerpunkt: Systemintegration | 2 |
| Systemanbieter liefert Plattform | 1 |
| Einzelprodukt liefert ben√∂tigte Funktionalit√§t | 1 |
| Entwicklung flexibler L√∂sungen f√ºr Kundenprozesse | 2 |
| System basiert auf generischer L√∂sung und standardisierten Prozessen | 1 |
| Wartung = Verantwortung des Systembesitzers | 2 |

**Beispielsysteme f√ºr beide Ans√§tze:**

- **Konfigurierbares Anwendungssystem**: SAP ERP
- **Integriertes Anwendungssystem**: E-Commerce-System mit ERP- und E-Mail-Anbindung

---
---
---

√úbungsblatt 2
-------------

### Aufgabe 1. Beweggr√ºnde f√ºr die Entstehung des Komponentenbasierten Software-Engineerings

**Wiederverwendbarkeit**:  
- Softwarekomponenten k√∂nnen wiederverwendet werden, was Entwicklungszeit und Kosten spart.

**Modularit√§t**:  
- Komponenten sind unabh√§ngig, was Wartung und Erweiterung vereinfacht.

**Flexibilit√§t**:  
- Komponenten k√∂nnen ausgetauscht werden, ohne das gesamte System zu √§ndern.

**Skalierbarkeit**:  
- Komponenten k√∂nnen unabh√§ngig skaliert und optimiert werden.


### Aufgabe 2. Vier Grundlagen des Komponentenbasierten Software-Engineerings

**Unabh√§ngige Komponenten**:  
- Komponenten k√∂nnen ohne System√§nderungen ausgetauscht werden.

**Komponentenstandards**:  
- Einheitliche Schnittstellen und Integrationen sind wichtig.

**Middleware**:  
- Unterst√ºtzung f√ºr Kommunikation, Ressourcenmanagement, Transaktionen, Sicherheit und Parallelit√§t.

**Komponentenorientierter Entwicklungsprozess**:  
- Komponenten k√∂nnen w√§hrend der Planung und Entwicklung angepasst und wiederverwendet werden.


### Aufgabe 3. Probleme der Vertrauensw√ºrdigkeit von Komponenten

**Blackbox-Natur**:  
- Quellcode nicht verf√ºgbar, schwierige Transparenz.

**Kein Zugriff auf den Quellcode**:  
- Es ist schwierig, Fehler zu erkennen.

**Unerwartete Seiteneffekte**:  
- Das Zusammenspiel von Komponenten kann unvorhergesehene Probleme verursachen.


### Aufgabe 4. Drei grundlegende Entwurfsprinzipien des Komponentenbasierten Software-Engineerings

**Unabh√§ngigkeit**:  
- Komponenten beeinflussen sich nicht gegenseitig.

**Klar definierte Schnittstellen**:  
- Stabiler API-Austausch m√∂glich.

**Komponenteninfrastruktur mit Standarddiensten**:  
- Weniger Eigenentwicklung notwendig, Fokus auf Integration.


### Aufgabe 5. Eigenschaften von Komponenten (Sommerville)

**Unabh√§ngigkeit**:  
- Komponenten sind autonome Einheiten.

**Modularit√§t**:  
- Komponenten sind isolierte Einheiten, die unabh√§ngig entwickelt werden k√∂nnen.

**Wiederverwendbarkeit**:  
- Komponenten k√∂nnen in verschiedenen Systemen verwendet werden.

**Dienstanbieter**:  
- Komponenten bieten Dienste, ohne dass der Benutzer den internen Zustand kennt.


### Aufgabe 6. Kritische Vorteile der Betrachtung einer Komponente als Dienstanbieter

**Unabh√§ngigkeit**:  
- Komponenten werden √ºber Schnittstellen aufgerufen und sind nicht von der Umgebung abh√§ngig.

**Sprachunabh√§ngigkeit**:  
- Komponenten k√∂nnen in verschiedenen Programmiersprachen implementiert werden.


### Aufgabe 7. Unterschiede zwischen Komponenten und Objekten

| Merkmal              | Komponente                        | Objekt                         |
|----------------------|-----------------------------------|--------------------------------|
| **Deployment**        | Direkt auf Plattform installierbar | Teil eines Programms (kompiliert) |
| **Typdefinition**     | Instanz                           | Basierend auf Klasse (Typ)    |
| **Transparenz**       | Blackbox (nur Schnittstelle sichtbar) | Oft transparenter (mehr Einblick) |
| **Sprachabh√§ngigkeit**| Sprachunabh√§ngig                  | Sprachgebunden (z. B. Java)    |
| **Standardisierung**  | Muss Modell folgen                | Frei definierbar               |


### Aufgabe 8. Unterschiedliche Schnittstellen von Komponenten

**Bereitgestellte Schnittstelle (provided interface)**:  
- Definiert die Dienste, die von der Komponente angeboten werden.

**Ben√∂tigte Schnittstelle (required interface)**:  
- Definiert, welche Dienste die Komponente ben√∂tigt, ohne zu spezifizieren, wie sie bereitgestellt werden.


### Aufgabe 8. UML-Diagramm

---


### Aufgabe 10. UML-Darstellung der ‚ÄûDataBroker‚Äú-Komponente

- Eine Komponente wird durch ein Rechteck dargestellt, das die Schnittstellen und die dazugeh√∂rigen ‚Äûbereitgestellten‚Äú und ‚Äûben√∂tigten‚Äú Schnittstellen (mit kleinen Rechtecken) enth√§lt.


### Aufgabe 11. Prinzip eines Komponentenmodells

**Prinzip**:  
- Ein Komponentenmodell definiert, wie Komponenten strukturiert, interagieren und konfiguriert werden.

**Beispiele**:  
- SOAP (WSDL), Jakarta Beans (CDI), Microsoft .NET (CIL).


### Aufgabe 12. Drei allgemeine Aspekte der Grundelemente eines Komponentenmodells

**Schnittstellen**:  
- Definiert die bereitgestellten und ben√∂tigten Dienste.

**Nutzung**:  
- Globale Bezeichner (z. B. URI, JNDI).

**Bereitstellung & Verpackung**:  
- Konfiguration, Dokumentation und Meta-Informationen.


### Aufgabe 13. Unterschied zwischen Plattform- und Hilfsdiensten einer Middleware

**Plattformdienste**:  
- Grundlegende Funktionen wie Kommunikation, Ressourcenverwaltung, Transaktionen, Persistenz.

**Hilfsdienste**:  
- Erg√§nzende Dienste wie Authentifizierung, die Inkompatibilit√§ten verhindern.


### Aufgabe 14. Implementierung eines Komponentenmodells

**Container**:  
- Eine Laufzeitumgebung, die Middleware-Dienste f√ºr die Ausf√ºhrung von Komponenten bereitstellt.


### Aufgabe 15. Aussagen zu Containern und Komponenten

| Aussage                                                         | Ja/Nein |
|-----------------------------------------------------------------|---------|
| Ein Container ist die Hauptkomponente jeder Applikation         | Nein    |
| Eine Komponente kann auf den Transaktionsdienst zugreifen      | Ja      |
| Der Container erm√∂glicht, dass Komponente A auf die Schnittstelle von B zugreifen kann | Ja      |
| Komponenten sind Hilfsdienste des Containers                    | Nein    |
| Der Container kann auf Komponentenschnittstellen zugreifen      | Nein    |
| Die Adressierung von Komponenten ist ein Hilfsdienst des Containers | Ja      |

---
---
---
#### √úbungsblatt 3
-------------

#### √úbungsblatt 4
-------------



Mamechishiki
-------------

1. Ïú†Ïó∞ÏÑ± (Flexibility)
ÏòàÏãú: ÏÑúÎπÑÏä§ Íµ¨ÌòÑÏ≤¥ Î≥ÄÍ≤Ω

    ÏÉÅÌô©: UserControllerÍ∞Ä UserServiceÎ•º Ìò∏Ï∂úÌïòÍ≥† ÏûàÎäîÎç∞, Í∑∏ÎèôÏïà **UserService**Îäî Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏóêÏÑú ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò§Îäî Î∞©ÏãùÏúºÎ°ú Íµ¨ÌòÑÎêòÏóàÏäµÎãàÎã§. Í∑∏Îü∞Îç∞ ÏÉàÎ°úÏö¥ ÏöîÍµ¨ ÏÇ¨Ìï≠Ïù¥ ÏÉùÍ≤ºÏñ¥Ïöî. Ïù¥Ï†úÎäî Ïô∏Î∂Ä APIÏóêÏÑú ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏ÏôÄÏïº ÌïúÎã§Í≥† Ìï©ÎãàÎã§.

ÏßÅÏ†ë Í∞ùÏ≤¥ ÏÉùÏÑ± Î∞©Ïãù (ÏàòÏ†ïÏù¥ ÌïÑÏöîÌï®)

public class UserController {
    private UserService userService = new UserService(); // ÏßÅÏ†ë Í∞ùÏ≤¥ ÏÉùÏÑ±

    public void getUserInfo() {
        userService.fetchUserData();
    }
}

    ÎßåÏïΩ **UserService**Ïùò Íµ¨ÌòÑÏù¥ Î≥ÄÍ≤ΩÎêúÎã§Î©¥, UserControllerÎèÑ ÏàòÏ†ïÌï¥Ïïº Ìï©ÎãàÎã§. API Ìò∏Ï∂úÏùÑ ÌÜµÌïú ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞Î°ú Î≥ÄÍ≤ΩÌïòÎ†§Î©¥, UserControllerÏùò ÏΩîÎìúÏóêÏÑú **UserService**Î•º ÏÉàÎ°ú ÏûëÏÑ±Îêú API Ìò∏Ï∂ú ÏÑúÎπÑÏä§Î°ú ÍµêÏ≤¥Ìï¥ÏïºÍ≤†Ï£†.

ÏùòÏ°¥ÏÑ± Ï£ºÏûÖ (Ïú†Ïó∞Ìï®)

@RestController
public class UserController {
    private final UserService userService;

    @Autowired
    public UserController(UserService userService) {
        this.userService = userService; // SpringÏù¥ ÏûêÎèôÏúºÎ°ú Ï£ºÏûÖ
    }

    public void getUserInfo() {
        userService.fetchUserData();
    }
}

    UserControllerÎäî Ïù¥Ï†ú UserServiceÏóê ÏùòÏ°¥ÌïòÏßÄÎßå Íµ¨ÌòÑÏ≤¥Ïóê ÎåÄÌïú Íµ¨Ï≤¥Ï†ÅÏù∏ ÏÇ¨Ìï≠ÏùÄ Ïã†Í≤Ω Ïì∞ÏßÄ ÏïäÏäµÎãàÎã§.

    ÎßåÏïΩ **UserService**Î•º **UserApiService**Î°ú ÍµêÏ≤¥ÌïòÍ≥† Ïã∂Îã§Î©¥, Spring ÏÑ§Ï†ïÎßå ÏàòÏ†ïÌïòÎ©¥ Îê©ÎãàÎã§. UserController ÏΩîÎìúÎäî Î≥ÄÍ≤ΩÌïòÏßÄ ÏïäÏïÑÎèÑ ÎèºÏöî.

    ÏòàÎ•º Îì§Ïñ¥, Spring Ïª®ÌÖåÏù¥ÎÑàÏóê UserService ÎåÄÏã† UserApiServiceÎ•º Îì±Î°ùÌïòÎ©¥, SpringÏù¥ ÏûêÎèôÏúºÎ°ú UserApiServiceÎ•º Ï£ºÏûÖÌï¥Ï§çÎãàÎã§. Í∑∏ÎßåÌÅº Ïú†Ïó∞ÏÑ±Ïù¥ ÎÜíÏïÑÏßëÎãàÎã§.

2. ÌÖåÏä§Ìä∏ Ïö©Ïù¥ÏÑ± (Testability)
ÏòàÏãú: Mock Í∞ùÏ≤¥Î•º Ïù¥Ïö©Ìïú ÌÖåÏä§Ìä∏

    ÏÉÅÌô©: UserServiceÎ•º ÌÖåÏä§Ìä∏ÌïòÎäîÎç∞, Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÎÇò Ïô∏Î∂Ä APIÎ•º Ìò∏Ï∂úÌïòÎäî Í≤ÉÏù¥ ÏïÑÎãàÎùº, ÏÑúÎπÑÏä§ Î°úÏßÅÎßå ÌÖåÏä§Ìä∏ÌïòÍ≥† Ïã∂Ïñ¥Ïöî. Ïù¥Î†áÍ≤å ÎêòÎ©¥ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÎÇò API Ìò∏Ï∂úÏùÑ Mock Ï≤òÎ¶¨Ìï¥ÏÑú ÌÖåÏä§Ìä∏Ìï† Ïàò ÏûàÏñ¥Ïïº Ìï©ÎãàÎã§.

ÏßÅÏ†ë Í∞ùÏ≤¥ ÏÉùÏÑ± Î∞©Ïãù (ÌÖåÏä§Ìä∏ Ïñ¥Î†§ÏõÄ)

public class UserController {
    private UserService userService = new UserService(); // Ïã§Ï†ú Í∞ùÏ≤¥Î•º ÏßÅÏ†ë ÏÉùÏÑ±

    public void getUserInfo() {
        userService.fetchUserData(); // Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ìò∏Ï∂ú
    }
}

    UserControllerÏóêÏÑú **UserService**Î•º ÏßÅÏ†ë ÏÉùÏÑ±ÌïòÎ©¥, ÌÖåÏä§Ìä∏Ìï† ÎïåÎßàÎã§ Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÎÇò API Ìò∏Ï∂úÏùÑ Ìï¥Ïïº ÌïòÎØÄÎ°ú, ÌÖåÏä§Ìä∏Í∞Ä Î≥µÏû°ÌïòÍ≥† ÎäêÎ†§ÏßëÎãàÎã§.

    Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏôÄ Ïô∏Î∂Ä APIÎäî ÌÖåÏä§Ìä∏ ÌôòÍ≤ΩÏóêÏÑú ÏÑ§Ï†ïÌïòÍ∏∞ Ïñ¥Î†§Ïö¥ Í≤ΩÏö∞ÎèÑ ÎßéÍ∏∞ ÎïåÎ¨∏Ïóê, ÌÖåÏä§Ìä∏ÌïòÍ∏∞ ÌûòÎì† ÏÉÅÌô©Ïù¥ Î∞úÏÉùÌï† Ïàò ÏûàÏäµÎãàÎã§.

ÏùòÏ°¥ÏÑ± Ï£ºÏûÖ (ÌÖåÏä§Ìä∏ Ïö©Ïù¥ÏÑ±)

public class UserControllerTest {
    @Mock
    private UserService userService; // Mock Í∞ùÏ≤¥ ÏÇ¨Ïö©

    private UserController userController;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        userController = new UserController(userService); // Mock Í∞ùÏ≤¥ Ï£ºÏûÖ
    }

    @Test
    public void testGetUserInfo() {
        when(userService.fetchUserData()).thenReturn("Test User Data");

        String result = userController.getUserInfo();

        assertEquals("Test User Data", result);
    }
}

    UserControllerÎäî Ïù¥Ï†ú **UserService**Î•º ÏùòÏ°¥ÏÑ± Ï£ºÏûÖÎ∞õÍ∏∞ ÎïåÎ¨∏Ïóê, Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÎÇò API Ìò∏Ï∂úÏùÑ ÌïòÏßÄ ÏïäÍ≥†ÎèÑ Mock Í∞ùÏ≤¥Î•º Ï£ºÏûÖÌïòÏó¨ ÌÖåÏä§Ìä∏Ìï† Ïàò ÏûàÏäµÎãàÎã§.

    MockitoÏôÄ Í∞ôÏùÄ ÎùºÏù¥Î∏åÎü¨Î¶¨Î•º ÏÇ¨Ïö©ÌïòÏó¨ UserServiceÎ•º Mock Ï≤òÎ¶¨ÌïòÍ≥†, ÏõêÌïòÎäî Îç∞Ïù¥ÌÑ∞Î•º Î∞òÌôòÌïòÍ≤å ÏÑ§Ï†ïÌï† Ïàò ÏûàÏñ¥Ïöî.

    Ïù¥ Î∞©ÏãùÏúºÎ°ú Ïã§Ï†ú ÏÑúÎπÑÏä§Í∞Ä ÏïÑÎãå **Í∞ÄÏßú ÏÑúÎπÑÏä§(Mock)**Î•º ÏÇ¨Ïö©Ìï¥ ÌÖåÏä§Ìä∏Ìï† Ïàò ÏûàÍ∏∞ ÎïåÎ¨∏Ïóê, ÌÖåÏä§Ìä∏Í∞Ä Îπ†Î•¥Í≥† Ìö®Ïú®Ï†ÅÏûÖÎãàÎã§.
    
    
    
    
    
    ...
    
    
    ÏòàÏãú: UserServiceÎ•º UserApiServiceÎ°ú ÍµêÏ≤¥ÌïòÍ∏∞
1. UserService Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ÏôÄ Íµ¨ÌòÑÏ≤¥ (UserServiceImpl)

public interface UserService {
    void fetchUserData();
}

@Service
public class UserServiceImpl implements UserService {
    @Override
    public void fetchUserData() {
        // DBÏóêÏÑú ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
    }
}

2. UserApiService Íµ¨ÌòÑÏ≤¥

@Service
public class UserApiService implements UserService {
    @Override
    public void fetchUserData() {
        // Ïô∏Î∂Ä APIÏóêÏÑú ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
    }
}

3. Spring ÏÑ§Ï†ïÎßå ÏàòÏ†ï (Íµ¨ÌòÑÏ≤¥ Î≥ÄÍ≤Ω)

@Configuration
public class ServiceConfig {

    @Bean
    public UserService userService() {
        // Ïó¨Í∏∞ÏÑú Í∏∞Ï°¥ UserServiceImplÏùÑ UserApiServiceÎ°ú Î∞îÍøîÏ£ºÎ©¥ Îê®
        return new UserApiService();
    }
}



....


SOLID

1. ‚úÖ Îã®Ïùº Ï±ÖÏûÑ ÏõêÏπô (Single Responsibility Principle)

    ÌÅ¥ÎûòÏä§Îäî ÌïòÎÇòÏùò ÏùºÎßå Ìï¥Ïïº ÌïúÎã§.

Ïòà:
UserServiceÎäî "ÌöåÏõê Í∞ÄÏûÖ"Îßå Ìï¥ÏïºÏßÄ, "ÌååÏùº Ï†ÄÏû•"ÍπåÏßÄ Ìï¥Î≤ÑÎ¶¨Î©¥ ÎÑàÎ¨¥ Î∞îÎπ†Ï†∏.
‚Üí Í∏∞Îä•ÏùÑ ÎÇòÎàÑÎ©¥ Ïú†ÏßÄÎ≥¥ÏàòÍ∞Ä Ïâ¨ÏõåÏ†∏!
2. üö™ Í∞úÎ∞©-ÌèêÏáÑ ÏõêÏπô (Open/Closed Principle)

    ÏΩîÎìúÎäî ÌôïÏû•ÏóêÎäî Ïó¥Î†§ ÏûàÍ≥†, Î≥ÄÍ≤ΩÏóêÎäî Îã´ÌòÄ ÏûàÏñ¥Ïïº ÌïúÎã§.

Ïòà:
ÏÉàÎ°úÏö¥ Í≤∞Ï†ú Î∞©Ïãù Ï∂îÍ∞ÄÌï† Îïå Í∏∞Ï°¥ ÏΩîÎìúÎ•º ÏàòÏ†ïÌïòÏßÄ ÎßêÍ≥†, ÏÉà ÌÅ¥ÎûòÏä§Î•º Ï∂îÍ∞ÄÌïòÏûê!
‚Üí Í∏∞Ï°¥ ÏΩîÎìú Ïïà Í±¥ÎìúÎ¶¨Í≥†ÎèÑ Í∏∞Îä•ÏùÑ ÌôïÏû•Ìï† Ïàò ÏûàÏùå!
3. üß¨ Î¶¨Ïä§ÏΩîÌîÑ ÏπòÌôò ÏõêÏπô (Liskov Substitution Principle)

    ÏûêÏãù ÌÅ¥ÎûòÏä§Îäî Î∂ÄÎ™® ÌÅ¥ÎûòÏä§Î•º ÏôÑÏ†ÑÌûà ÎåÄÏ≤¥Ìï† Ïàò ÏûàÏñ¥Ïïº Ìï®.

Ïòà:
Bird ‚Üí Penguin ÏÉÅÏÜçÌñàÎäîÎç∞, fly() Ìò∏Ï∂úÌïòÎãà Ïò§Î•òÎÇ®?
‚Üí Í∑∏Îüº LSP ÏúÑÎ∞ò! Î∂ÄÎ™® ÎåÄÏ≤¥Í∞Ä Ïïà ÎêòÏûñÏïÑ üòÖ
4. üß© Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ Î∂ÑÎ¶¨ ÏõêÏπô (Interface Segregation Principle)

    Ïù∏ÌÑ∞ÌéòÏù¥Ïä§Îäî ÏûëÍ≥† Íµ¨Ï≤¥Ï†ÅÏúºÎ°ú ÎÇòÎà†Îùº.

Ïòà:
Animal Ïù∏ÌÑ∞ÌéòÏù¥Ïä§Ïóê walk(), fly(), swim()Ïù¥ Îã§ ÏûàÏúºÎ©¥...
Í≥†ÏñëÏù¥ÎèÑ fly() Íµ¨ÌòÑÌï¥Ïïº ÌïúÎã§Í≥†?! ü§Ø
‚Üí Í∏∞Îä•Î≥Ñ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§Î°ú Î∂ÑÎ¶¨ÌïòÏûê!
5. üîÑ ÏùòÏ°¥ÏÑ± Ïó≠Ï†Ñ ÏõêÏπô (Dependency Inversion Principle)

    Íµ¨ÌòÑÏ≤¥Í∞Ä ÏïÑÎãàÎùº Ïù∏ÌÑ∞ÌéòÏù¥Ïä§(Ï∂îÏÉÅ)Ïóê ÏùòÏ°¥Ìï¥Îùº
    ‚Üí Ïù¥ÎØ∏ ÏïûÏóêÏÑú ÏÑ§Î™ÖÌñàÏßÄ? üòä
    
    
    
    ...
    
    
    üîÑ Ïª¥Ìè¨ÎÑåÌä∏ Í∏∞Î∞ò ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ Í≥µÌïô vs Spring Boot
‚úÖ 1. Ïª¥Ìè¨ÎÑåÌä∏ = Ïä§ÌîÑÎßÅ Îπà (@Component, @Service Îì±)

    KBSEÏóêÏÑúÎäî 'Ïª¥Ìè¨ÎÑåÌä∏'Î•º ÎèÖÎ¶ΩÏ†ÅÏúºÎ°ú Ïû¨ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ Îã®ÏúÑÎ°ú ÏÑ§Î™ÖÌñàÏßÄ?

    Ïä§ÌîÑÎßÅÏóêÏÑúÎäî Ïù¥Îü∞ Îã®ÏúÑÎ•º @Component, @Service, @Repository, @Controller Í∞ôÏùÄ Ïï†ÎÖ∏ÌÖåÏù¥ÏÖòÏúºÎ°ú Îì±Î°ùÌïú **Îπà(Bean)**Ïù¥ÎùºÍ≥† Î≥¥Î©¥ Îèº.

üëâ ÏòàÏãú:

@Service
public class UserService {
    public String getUser() {
        return "ÌôçÍ∏∏Îèô";
    }
}

‚úÖ 2. Ï†úÍ≥µ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ / ÏöîÍµ¨ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ = DI (ÏùòÏ°¥ÏÑ± Ï£ºÏûÖ)

    KBSEÏóêÏÑú Ï†úÍ≥µ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§Îäî Ïª¥Ìè¨ÎÑåÌä∏Í∞Ä "Ïù¥ Í∏∞Îä• Ìï¥Ï§ÑÍ≤å!"ÎùºÍ≥† ÏïΩÏÜçÌïú APIÏïº.

    ÏöîÍµ¨ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§Îäî "ÎÇò Ïù¥Í±∞ ÌïÑÏöîÌï¥!"ÎùºÍ≥† Ïô∏ÏπòÎäî Í∏∞Îä• ÏöîÏ≤≠Ïù¥Ïïº.

üëâ Ïä§ÌîÑÎßÅÏóêÏÑúÎäî Ïù¥Î†áÍ≤å ÌëúÌòÑÎèº:

@RestController
public class UserController {
    private final UserService userService;

    // ÏöîÍµ¨ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ (UserServiceÍ∞Ä ÌïÑÏöîÌï¥Ïöî!)
    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping("/user")
    public String getUser() {
        return userService.getUser(); // Ï†úÍ≥µ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ Ìò∏Ï∂ú
    }
}

‚úÖ 3. ÍµêÏ≤¥ Í∞ÄÎä•ÏÑ± (Ïú†Ïó∞ÏÑ±)

    üéØ Ïª¥Ìè¨ÎÑåÌä∏Î•º Îã§Î•∏ Í≤ÉÏúºÎ°ú ÍµêÏ≤¥Ìï† Ïàò ÏûàÎäî Ïú†Ïó∞ÏÑ± ‚Äî Ïä§ÌîÑÎßÅÏùò Í∞ÄÏû• ÌÅ∞ Ïû•Ï†ê Ï§ë ÌïòÎÇòÏßÄ!

üëâ ÏòàÏãú: UserService ÎåÄÏã† UserApiServiceÎ°ú Î∞îÍæ∏Í≥† Ïã∂ÏùÑ Îïå!

public interface UserService {
    String getUser();
}

@Service
public class UserApiService implements UserService {
    public String getUser() {
        return "APIÏóêÏÑú Í∞ÄÏ†∏Ïò® ÏÇ¨Ïö©Ïûê";
    }
}

@Configuration
public class AppConfig {
    @Bean
    public UserService userService() {
        return new UserApiService(); // Íµ¨ÌòÑÏ≤¥ ÍµêÏ≤¥!
    }
}

üß† UserControllerÎäî Ïù∏ÌÑ∞ÌéòÏù¥Ïä§Îßå ÏïåÍ≥† ÏûàÍ≥† Íµ¨ÌòÑÏ≤¥Îäî Î™∞Îùº! ‚Üí Î≥ÄÍ≤ΩÏù¥ ÏûàÏñ¥ÎèÑ ÏΩîÎìúÎ•º Ïïà Í≥†Ï≥êÎèÑ Îèº.
‚úÖ 4. ÎØ∏Îì§Ïõ®Ïñ¥ = Ïä§ÌîÑÎßÅ Ïª®ÌÖåÏù¥ÎÑà

    KBSEÏóêÏÑú ÎØ∏Îì§Ïõ®Ïñ¥Îäî Ïª¥Ìè¨ÎÑåÌä∏Îì§Ïù¥ Ïûò ÏûëÎèôÌïòÎèÑÎ°ù ÎèÑÏôÄÏ£ºÎäî ÌôòÍ≤ΩÏù¥ÎùºÍ≥† ÌñàÏûñÏïÑ?

    Ïä§ÌîÑÎßÅÏóêÏÑúÎäî Ïù¥ Ïó≠Ìï†ÏùÑ ApplicationContext (Ïä§ÌîÑÎßÅ Ïª®ÌÖåÏù¥ÎÑà) Í∞Ä Ìï¥!

üëâ ÏòàÎ•º Îì§Ïñ¥:

    Ìä∏ÎûúÏû≠ÏÖò Í¥ÄÎ¶¨ (@Transactional)

    Î≥¥Ïïà (Spring Security)

    AOP (@Aspect)

    Î¶¨ÏÜåÏä§ Í¥ÄÎ¶¨, Îπà Ï£ºÏûÖ Îì±Îì±!

‚úÖ 5. Ïª®ÌÖåÏù¥ÎÑà = ApplicationContext (ÎòêÎäî IoC Ïª®ÌÖåÏù¥ÎÑà)

    KBSEÏùò Ïª®ÌÖåÏù¥ÎÑàÎäî Ïª¥Ìè¨ÎÑåÌä∏Î•º Ïã§ÌñâÏãúÏºúÏ£ºÎäî Í≥µÍ∞Ñ.

    Ïä§ÌîÑÎßÅÏóêÏÑúÎèÑ Ïö∞Î¶¨Í∞Ä ÎßåÎìúÎäî Î™®Îì† ÎπàÎì§Ïù¥ Ïù¥ Ïª®ÌÖåÏù¥ÎÑàÏóêÏÑú Í¥ÄÎ¶¨Îèº.

‚úÖ 6. ÌÖåÏä§Ìä∏ Ïö©Ïù¥ÏÑ±

    DI ÎçïÎ∂ÑÏóê ÏõêÌïòÎäî Íµ¨ÌòÑÏ≤¥Î°ú ÍµêÏ≤¥Ìï¥ÏÑú ÌÖåÏä§Ìä∏ Í∞ÄÎä•!

üëâ ÏòàÏãú:

class MockUserService implements UserService {
    public String getUser() {
        return "ÌÖåÏä§Ìä∏ ÏÇ¨Ïö©Ïûê";
    }
}

ÌÖåÏä§Ìä∏ÏóêÏÑúÎäî Ïù¥Í±∏ Ï£ºÏûÖÌï¥ÏÑú, Ïã§Ï†ú DBÎÇò API ÏóÜÏù¥ÎèÑ ÌÖåÏä§Ìä∏Ìï† Ïàò ÏûàÏñ¥!
