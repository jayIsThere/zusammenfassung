---
title: KBE
author: Jaehan Kim
date: 2025-04-10
category: KBE
layout: post
---

03.04.2025 - Vorlesung 1: Wiederverwendung von Software 1
-------------

### Einführung in die Softwarewiederverwendung

- **Definition:** Wiederverwendung bestehender Softwarekomponenten (z. B. Code, Module, Systeme)
- **Motivation:** Geringere Kosten, höhere Qualität, schnellere Markteinführung
- **Relevanz:** Besonders wichtig seit 2000 durch wachsende Softwarekomplexität und Kostendruck

### Skalierung wiederverwendbarer Softwareeinheiten

- **Systeme von Systemen:** Integration ganzer Systeme
- **Anwendungssysteme:** Konfigurierbare Standardsoftware
- **Anwendungsfamilien / Produktlinien:** Gemeinsame Architektur mit Anpassungsmöglichkeiten
- **Komponenten:** Module mittlerer Granularität
- **Objekte und Funktionen:** Kleinste Einheiten, oft in Bibliotheken

### Vorteile der Wiederverwendung

- **Kosten- und Zeitersparnis:** Weniger Entwicklung und Validierung notwendig
- **Zuverlässigkeit:** Durch getestete und bewährte Komponenten
- **Bessere Ressourcennutzung:** Spezialisten und Standards werden besser genutzt
- **Konsistenz und Standardisierung:** Z. B. bei UI-Komponenten

### Probleme der Wiederverwendung

- **Wartungsprobleme:** Unbekannter Quellcode führt zu Problemen bei Wartung und Erweiterung
- **Geringe Werkzeugunterstützung:** Besonders für eingebettete Systeme
- **„Not-invented-here“-Syndrom:** Widerstand gegen externe Komponenten
- **Aufwand für Komponentenbibliotheken:** Aufbau und Pflege sind arbeitsintensiv
- **Anpassung erfordert Expertise:** Finden und anpassen von Komponenten ist komplex

---
---
---

10.04.2025 - Vorlesung 2: Wiederverwendung von Software 2
-------------

### Wiederverwendungstechniken (laut Sommerville)

1. **Frameworks**
   - **Definition:** Ein Framework ist ein Set von Softwarekomponenten, das eine Architektur für verwandte Anwendungen bereitstellt.
   - **Beispiel:** Ein Web-Framework wie Spring MVC verwendet das Model-View-Controller-Muster.
   - **Eigenschaft:** Bietet generische Funktionalität und wird erweitert, nicht ersetzt.

2. **Inversion of Control (IoC)**
   - **Prinzip:** Die Steuerung liegt beim Framework, nicht bei der Anwendung. Die Anwendung registriert ihre Komponenten, und das Framework ruft sie bei Bedarf auf.
   - **Beispiel:** Callbacks in Web-Frameworks.

3. **Entwurfsmuster**
   - **Beispiel:** Observer, Strategy sind gängige Muster, um wiederkehrende Probleme zu lösen.

4. **Architekturmuster**
   - **Beispiel:** Microservices bieten eine systemweite Lösung für komplexe Anwendungen.

5. **ERP-Systeme**
   - **Definition:** Unternehmensweite Systeme mit konfigurierbaren Modulen.
   - **Vorteil:** Bietet Lösungen für die Verwaltung von Geschäftsdaten und Prozessen.

6. **Komponentenbasierte Entwicklung**
   - **Prinzip:** Systeme werden aus austauschbaren Komponenten aufgebaut.

7. **Modellgetriebene Entwicklung**
   - **Definition:** Software wird aus plattformunabhängigen Modellen erstellt.

8. **Serviceorientierte Systeme**
   - **Prinzip:** Nutzung verteilter Webservices (z. B. REST, SOAP) zur Kommunikation zwischen Komponenten.

9. **Softwareproduktlinien**
   - **Definition:** Produktfamilien mit einer gemeinsamen Codebasis und variablen Komponenten.

### Framework-Klassifizierung (nach Fayad & Schmidt)

- **Systeminfrastruktur-Frameworks:** Z. B. Kommunikation, GUI, Compiler
- **Middleware-Integrations-Frameworks:** Z. B. Jakarta EE, .NET für Komponentenkommunikation
- **Unternehmensanwendungs-Frameworks:** Z. B. spezialisierte Frameworks für Branchen wie Telekommunikation oder Finanzen.

### Wiederverwendung von Anwendungssystemen

- **Softwareproduktlinien:** Gemeinsamer Kern mit anpassbaren Komponenten
- **Konfigurierbare Systeme:** Über Parameter anpassbar (z. B. ERP-Systeme)
- **Integrierte Systeme:** Kombination verschiedener Anwendungen über Schnittstellen

### Vorteile und Herausforderungen

- **Vorteile:** Schnellere Bereitstellung und geringeres Entwicklungsrisiko
- **Herausforderungen:** Anpassung an Unternehmensprozesse, fehlende Expertise, Auswahl des richtigen Systems

---
---
---

### Übungsblatt (Statistik)
-------------

#### Übungsblatt 1

### Aufgabe 1. Grundstrategie des Software-Engineerings

**Ziel der Wiederverwendung**:  
- Wiederverwendung vorhandener Software, statt neue Software von Grund auf zu entwickeln.

### Aufgabe 2. Aspekte, die den Ansatz getrieben haben:

- Geringere Produktions- und Wartungskosten
- Schnellere Auslieferung von Systemen
- Höhere Softwarequalität

### Aufgabe 3. Beispiele für etablierte wiederverwendbare Software:

- Open Source Code (z. B. Apache Commons)
- ERP-Systeme (z. B. SAP)
- Komponentenbibliotheken
- Webservices (z. B. PayPal)

### Aufgabe 4. Größenordnungen von Softwareeinheiten (von groß nach klein):

- Systeme
- Anwendungen
- Softwareproduktlinien
- Komponenten
- Objekte und Funktionen

### Aufgabe 5. Beispiele für jede Größenordnung:

- **System**: Ein ERP-System, z. B. SAP
- **Anwendung**: Ein CRM-System
- **Produktlinie**: Softwarelinie für medizinische Geräte
- **Komponente**: Zahlungsmodul
- **Funktion/Objekt**: Logging-Klasse aus Apache Commons

### Aufgabe 6. Vorteile der Wiederverwendung:

- Geringere Kosten
- Höhere Zuverlässigkeit
- Geringeres Entwicklungsrisiko
- Schnellere Markteinführung
- Effektiver Einsatz von Experten
- Standardkonformität

### Aufgabe 6. Probleme der Wiederverwendung:

- Höhere Wartungskosten
- Mangel an Werkzeugunterstützung
- "Not-invented-here"-Syndrom
- Hoher Aufwand für Bibliotheksverwaltung
- Schwierige Suche und Anpassung von Komponenten

### Aufgabe 7. Planung der Wiederverwendung

**Vier Schlüsselfaktoren:**

- Entwicklungszeitplan
- Erwartete Lebensdauer der Software
- Erfahrung des Entwicklerteams
- Wichtigkeit/Nicht-funktionale Anforderungen

### Aufgabe 8. Schlüsselfaktoren bei .NET und schneller Verfügbarkeit:

- Plattformabhängigkeit (→ .NET-Kompatibilität)
- Geringer Entwicklungsaufwand durch Wiederverwendung fertiger Systeme

### Aufgabe 9-12. Anwendungsframeworks

**Attribute von Frameworks:**

| Attribut | Passt? |
|----------|--------|
| Konfigurierbar | ✅ Ja |
| Generisch | ✅ Ja |
| Call-back | ✅ Ja |
| Unterstützung konkreter Geschäftsaktivitäten | ✅ Ja |
| Inversion of Control | ✅ Ja |
| Inhärent erweiterbar | ✅ Ja |
| Basis sehr ähnlicher Systeme | ✅ Ja |
| Unterstützung für Hardware-Schnittstellen | ❌ Teilweise (meist Software) |
| Immer objektorientiert | ❌ Nein (meist, aber nicht zwingend) |

**Drei Architektur- und Entwurfsmuster, auf denen WAFs basieren:**

- Model-View-Controller (MVC)
- Observer Pattern
- Strategy Pattern (auch Composite Pattern möglich)

**Funktion von WAFs oder Entwicklern:**

| Funktion | WAF | ENT |
|----------|-----|-----|
| Zahlungstransaktion über Kreditkarte durchführen |  | ✅ |
| Verwaltung des Inhalts eines Shop-Warenkorbs | ✅ |  |
| Abfragedaten in einer Tabelle aufbereiten | ✅ |  |
| Am System anmelden und abmelden | ✅ |  |
| Zugriff auf ein Geoinformationsdienst |  | ✅ |
| Bestimmung des aktuellen Standorts über GPS |  | ✅ |
| Asynchrone Aktualisierung durch Auswahl eines Listeneintrags | ✅ |  |
| Geänderte Daten nach dem Speichern sichtbar machen | ✅ |  |
| Ermittlung verschiedener Bahn-Routen |  | ✅ |
| Nutzung einer 3D-Spiele-Engine |  | ✅ |
| Geschäftsdaten persistieren | ✅ |  |

**Unterschied Framework vs. Bibliothek:**

- Bei **Bibliotheken** ruft die Anwendung die Bibliothek auf.
- Bei **Frameworks** ruft das Framework die Anwendung auf.
    - → Inversion of Control (IoC, „Hollywood Principle“: "Don't call us, we'll call you")

### Aufgabe 13-15. Softwareproduktlinien

**Was ist eine Softwareproduktlinie und wann ist sie effizient?**  
- Eine Produktlinie ist ein Satz verwandter Anwendungen mit gemeinsamer Architektur.
- Effizient, wenn viele ähnliche, aber nicht identische Systeme benötigt werden.

**Aufbau des Basissystems:**

- Kernkomponenten (nicht veränderbar)
- Konfigurierbare Komponenten
- Spezielle Anwendungskomponenten

**Voraussetzung bei Nutzung von Frameworks für Produktlinien:**

- Das Framework muss erweiterbar und anpassbar sein, um domänenspezifische Komponenten einzubetten.

### Aufgabe 16-19. Anwendungssysteme

**Welche Aussagen über Anwendungssysteme sind korrekt?**

| Aussage | Ja |
|---------|-----|
| Lassen sich viel schneller zuverlässig bereitstellen | ✅ |
| Sind im Kern sehr gut auf kundenspezifische Bedürfnisse zugeschnitten | ❌ |
| Support-Ratschläge = Verkaufsfokus, nicht Bedarfsermittlung | ✅ |
| Gut zur Abbildung bestehender Geschäftsprozesse geeignet | ✅ |
| Anpassbar ohne Quellcode-Änderung | ✅ |
| Technologie-Updates = Verantwortung des Herstellers | ✅ |
| Für Unternehmen mit ähnlichen Systemanforderungen geeignet | ✅ |

**Zwei Ansätze von Anwendungssystemen:**

- **Konfigurierbare Anwendungssysteme**: Einzelprodukt, Konfiguration
- **Integration von Anwendungssystemen**: Mehrere Systeme, Anpassung durch Integration

**Zuordnung der Aussagen:**

| Aussage | Ansatz |
|---------|--------|
| Schwerpunkt: Systemintegration | 2 |
| Systemanbieter liefert Plattform | 1 |
| Einzelprodukt liefert benötigte Funktionalität | 1 |
| Entwicklung flexibler Lösungen für Kundenprozesse | 2 |
| System basiert auf generischer Lösung und standardisierten Prozessen | 1 |
| Wartung = Verantwortung des Systembesitzers | 2 |

**Beispielsysteme für beide Ansätze:**

- **Konfigurierbares Anwendungssystem**: SAP ERP
- **Integriertes Anwendungssystem**: E-Commerce-System mit ERP- und E-Mail-Anbindung

---
---
---

#### Übungsblatt 2

### Aufgabe 1. Beweggründe für die Entstehung des Komponentenbasierten Software-Engineerings

**Wiederverwendbarkeit**:  
- Softwarekomponenten können wiederverwendet werden, was Entwicklungszeit und Kosten spart.

**Modularität**:  
- Komponenten sind unabhängig, was Wartung und Erweiterung vereinfacht.

**Flexibilität**:  
- Komponenten können ausgetauscht werden, ohne das gesamte System zu ändern.

**Skalierbarkeit**:  
- Komponenten können unabhängig skaliert und optimiert werden.

### Aufgabe 2. Vier Grundlagen des Komponentenbasierten Software-Engineerings

**Unabhängige Komponenten**:  
- Komponenten können ohne Systemänderungen ausgetauscht werden.

**Komponentenstandards**:  
- Einheitliche Schnittstellen und Integrationen sind wichtig.

**Middleware**:  
- Unterstützung für Kommunikation, Ressourcenmanagement, Transaktionen, Sicherheit und Parallelität.

**Komponentenorientierter Entwicklungsprozess**:  
- Komponenten können während der Planung und Entwicklung angepasst und wiederverwendet werden.

### Aufgabe 3. Probleme der Vertrauenswürdigkeit von Komponenten

**Blackbox-Natur**:  
- Quellcode nicht verfügbar, schwierige Transparenz.

**Kein Zugriff auf den Quellcode**:  
- Es ist schwierig, Fehler zu erkennen.

**Unerwartete Seiteneffekte**:  
- Das Zusammenspiel von Komponenten kann unvorhergesehene Probleme verursachen.

### Aufgabe 4. Drei grundlegende Entwurfsprinzipien des Komponentenbasierten Software-Engineerings

**Unabhängigkeit**:  
- Komponenten beeinflussen sich nicht gegenseitig.

**Klar definierte Schnittstellen**:  
- Stabiler API-Austausch möglich.

**Komponenteninfrastruktur mit Standarddiensten**:  
- Weniger Eigenentwicklung notwendig, Fokus auf Integration.

### Aufgabe 5. Eigenschaften von Komponenten (Sommerville)

**Unabhängigkeit**:  
- Komponenten sind autonome Einheiten.

**Modularität**:  
- Komponenten sind isolierte Einheiten, die unabhängig entwickelt werden können.

**Wiederverwendbarkeit**:  
- Komponenten können in verschiedenen Systemen verwendet werden.

**Dienstanbieter**:  
- Komponenten bieten Dienste, ohne dass der Benutzer den internen Zustand kennt.

### Aufgabe 6. Kritische Vorteile der Betrachtung einer Komponente als Dienstanbieter

**Unabhängigkeit**:  
- Komponenten werden über Schnittstellen aufgerufen und sind nicht von der Umgebung abhängig.

**Sprachunabhängigkeit**:  
- Komponenten können in verschiedenen Programmiersprachen implementiert werden.

### Aufgabe 7. Unterschiede zwischen Komponenten und Objekten

| Merkmal              | Komponente                        | Objekt                         |
|----------------------|-----------------------------------|--------------------------------|
| **Deployment**        | Direkt auf Plattform installierbar | Teil eines Programms (kompiliert) |
| **Typdefinition**     | Instanz                           | Basierend auf Klasse (Typ)    |
| **Transparenz**       | Blackbox (nur Schnittstelle sichtbar) | Oft transparenter (mehr Einblick) |
| **Sprachabhängigkeit**| Sprachunabhängig                  | Sprachgebunden (z. B. Java)    |
| **Standardisierung**  | Muss Modell folgen                | Frei definierbar               |

### Aufgabe 8. Unterschiedliche Schnittstellen von Komponenten

**Bereitgestellte Schnittstelle (provided interface)**:  
- Definiert die Dienste, die von der Komponente angeboten werden.

**Benötigte Schnittstelle (required interface)**:  
- Definiert, welche Dienste die Komponente benötigt, ohne zu spezifizieren, wie sie bereitgestellt werden.

### Aufgabe 8. UML-Diagramm

---

### Aufgabe 10. UML-Darstellung der „DataBroker“-Komponente

- Eine Komponente wird durch ein Rechteck dargestellt, das die Schnittstellen und die dazugehörigen „bereitgestellten“ und „benötigten“ Schnittstellen (mit kleinen Rechtecken) enthält.

### Aufgabe 11. Prinzip eines Komponentenmodells

**Prinzip**:  
- Ein Komponentenmodell definiert, wie Komponenten strukturiert, interagieren und konfiguriert werden.

**Beispiele**:  
- SOAP (WSDL), Jakarta Beans (CDI), Microsoft .NET (CIL).

### Aufgabe 12. Drei allgemeine Aspekte der Grundelemente eines Komponentenmodells

**Schnittstellen**:  
- Definiert die bereitgestellten und benötigten Dienste.

**Nutzung**:  
- Globale Bezeichner (z. B. URI, JNDI).

**Bereitstellung & Verpackung**:  
- Konfiguration, Dokumentation und Meta-Informationen.

### Aufgabe 13. Unterschied zwischen Plattform- und Hilfsdiensten einer Middleware

**Plattformdienste**:  
- Grundlegende Funktionen wie Kommunikation, Ressourcenverwaltung, Transaktionen, Persistenz.

**Hilfsdienste**:  
- Ergänzende Dienste wie Authentifizierung, die Inkompatibilitäten verhindern.

### Aufgabe 14. Implementierung eines Komponentenmodells

**Container**:  
- Eine Laufzeitumgebung, die Middleware-Dienste für die Ausführung von Komponenten bereitstellt.

### Aufgabe 15. Aussagen zu Containern und Komponenten

| Aussage                                                         | Ja/Nein |
|-----------------------------------------------------------------|---------|
| Ein Container ist die Hauptkomponente jeder Applikation         | Nein    |
| Eine Komponente kann auf den Transaktionsdienst zugreifen      | Ja      |
| Der Container ermöglicht, dass Komponente A auf die Schnittstelle von B zugreifen kann | Ja      |
| Komponenten sind Hilfsdienste des Containers                    | Nein    |
| Der Container kann auf Komponentenschnittstellen zugreifen      | Nein    |
| Die Adressierung von Komponenten ist ein Hilfsdienst des Containers | Ja      |

---
---
---
#### Übungsblatt 3
#### Übungsblatt 4


